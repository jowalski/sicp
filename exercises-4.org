# -*- org-babel-use-quick-and-dirty-noweb-expansion: t; -*-
#+FILETAGS: @personal
#+LaTeX_HEADER: \newcommand{\mya}[2]{ ( A\, #1\, #2) }
#+LaTeX_HEADER: \usepackage{forest}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \newcommand{\leaf}[3]{{(cc #1 #2)\\[-1ex]\scriptsize #3}}
* Exercises for the Structure and Interpretation of Computer Languages
:PROPERTIES:
:header-args: :results silent :noweb yes
:header-args: :noweb yes
:END:
** 4 Metalinguistic Abstraction
The evaluator, which determines the meaning of expressions in a programming language, is just another program. In fact any program can be viewed as the evaluator for some language, like our polynomial manipulation system, or digital-logic simulator.
*** 4.1 The Metacircular Evaluator
We will implement our evaluator in Lisp, the same language the evaluator evaluates, thus it is "metacircular".

This will be a scheme formulation of the environment model of evaluation:

1. To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions.

2. To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment.  To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to which the procedure is applied.
**** 4.1.1 The Core of the Evaluator
The evaluation process can be described as the interplay between two procedures: ~eval~ and ~apply~.
***** Eval
See SICP for details, the definition of ~eval~ is a case analysis using ~cond~:

#+NAME: eval
#+begin_src scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Unknown expression type -- EVAL" exp))))
#+end_src

A disadvantage of using a case analysis is that no new types of expressions can be defined without editing the definition of ~eval~. In other Lisp implementations, dispatching is done in data-directed style that allows addition without modification of ~eval~.
***** Apply
~apply~ takes two arguments, a procedure and list of arguments. It classifies procedures into primitives and compound procedures.

#+NAME: apply
#+begin_src scheme
  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
             (procedure-body procedure)
             (extend-environment
               (procedure-parameters procedure)
               arguments
               (procedure-environment procedure))))
          (else
           (error
            "Unknown procedure type -- APPLY" procedure))))
#+end_src
***** Procedure arguments
#+NAME: list_of_values
#+begin_src scheme
  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
        (cons (eval (first-operand exps) env)
              (list-of-values (rest-operands exps) env))))
#+end_src
***** Conditionals
#+NAME: eval_if
#+begin_src scheme
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))
#+end_src
Note how ~true?~ works, it translates a value in the languages being implemented to a (boolean) value in the implementation language. "The metacircular representation of truth might not be the same as that of the underlying Scheme."

***** Sequences
#+NAME: eval_sequence
#+begin_src scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+end_src

***** Assignments and definitions
#+NAME: eval_assignment
#+begin_src scheme
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    'ok)
#+end_src

#+NAME: eval_definition
#+begin_src scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
                      (eval (definition-value exp) env)
                      env)
    'ok)
#+end_src

*Exercise 4.1*. Notice that we cannot tell whether the metacircular evaluator evaluates operands from left to right or from right to left.  Its evaluation order is inherited from the underlying Lisp: If the arguments to ~cons~ in ~list-of-values~ are evaluated from left to right, then ~list-of-values~ will evaluate operands from left to right; and if the arguments to ~cons~ are evaluated from right to left, then ~list-of-values~ will evaluate operands from right to left.

Write a version of ~list-of-values~ that evaluates operands from left to right regardless of the order of evaluation in the underlying Lisp.  Also write a version of ~list-of-values~ that evaluates operands from right to left.

#+begin_src scheme
  (define (list-of-values-l-to-r exps env)
    (if (no-operands? exps)
        '()
        (let ((first-evalled (eval (first-operand exps) env)))
          (cons first-evalled
                (list-of-values-l-to-r (rest-operands exps) env)))))

  (define (list-of-values-r-to-l exps env)
    (if (no-operands? exps)
        '()
        (let ((rest-evalled
               (list-of-values-r-to-l (rest-operands exps) env)))
          (cons (eval (first-operand exps) env)
                rest-evalled))))
#+end_src

**** 4.1.2 Representing Expressions
The evaluator is similar to the symbolic differentiation program in [[file:exercises-1-2.org::*2.3.2%20Example:%20Symbolic%20Differentiation][2-3-2]].
  * Both operate on symbolic expressions
  * the result of operating on a compound expression is determined by operating recursively on its parts, and combining them in a way dependent on the types of the expression
  * We've decoupled the rules of operation from the details of representation.

Below is the specification of the syntax of the language:

#+NAME: syntax
#+begin_src scheme
  ;; self-evaluating items
  (define (self-evaluating? exp)
    (cond ((number? exp) #t)
          ((string? exp) #t)
          (else #f)))

  ;; variables
  (define (variable? exp) (symbol? exp))

  ;; quotations
  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))


  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))

  ;; assignments
  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  ;; definitions
  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)   ; formal parameters
                     (cddr exp)))) ; body

  ;; lambda expressions
  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  ;; conditionals
  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  ;; begin expressions
  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  ;; procedure applications
  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))
#+end_src

*** Derived expressions
We define ~cond~ in terms of other special forms, rather than creating another special form.

#+NAME: cond
#+begin_src scheme
  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false                          ; no `else' clause
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last -- COND->IF"
                         clauses))
              (make-if (cond-predicate first)
                       (sequence->exp (cond-actions first))
                       (expand-clauses rest))))))
#+end_src

~let~ is another derived expression we will implement.

*Exercise 4.2*. Louis Reasoner plans to reorder the ~cond~ clauses in ~eval~ so that the clause for procedure applications appears before the clause for assignments.  He argues that this will make the interpreter more efficient: Since programs usually contain more applications than assignments, definitions, and so on, his modified ~eval~ will usually check fewer clauses than the original ~eval~ before identifying the type of an expression.

a. What is wrong with Louis's plan?  (Hint: What will Louis's evaluator do with the expression ~(define x 3)~?)

It will interpret the 'define expression as a procedure application, and attempt to apply 'define to '(x 3), which will presumably result in some type of error (we haven't defined exactly what because ~lookup-variable-value~ is undefined now).

As written:
  * (eval '(define x 3) env)
  * (cond ... ((definition? '(define x 3)) (eval-definition '(define x 3) env)) ...)
  * (define-variable! (definition-variable exp) (eval (definition-value exp) env) env)
  * (define-variable 'x (eval 3 env) env)

Putting procedure applications before assignments:
  * (eval '(define x 3) env)
  * (cond ...((application? '(define x 3)) (apply (eval ...) (list-of-values ...))))
  * (apply (eval 'define env) (list-of-values '(x 3) env))
  * (apply (lookup-variable-value 'define env) ...)
  * some type of error where 'define is not defined or reserved?

b. Louis is upset that his plan didn't work.  He is willing to go to any lengths to make his evaluator recognize procedure applications before it checks for most other kinds of expressions.  Help him by changing the syntax of the evaluated language so that procedure applications start with ~call~.  For example, instead of ~(factorial 3)~ we will now have to write ~(call factorial 3)~ and instead of ~(+ 1 2)~ we will have to write ~(call + 1 2)~.

#+begin_src scheme
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
#+end_src

*Exercise 4.3*. Rewrite ~eval~ so that the dispatch is done in data-directed style.  Compare this with the data-directed differentiation procedure of Exercise 2-73::.  (You may use the ~car~ of a compound expression as the type of the expression, as is appropriate for the syntax implemented in this section.)

#+NAME: special_forms
#+begin_src scheme
  (define (derived-exp exp-f)
    (lambda (exp env) (eval (exp-f exp) env)))

  (define special-forms
    (list
     '(quote  . (lambda (exp env) (text-of-quotation exp)))
     '(set!   . eval-assignment)
     '(define . eval-definition)
     '(if     . eval-if)
     '(lambda . (lambda (exp env)
                  (make-procedure (lambda-parameters exp)
                                  (lambda-body exp) env)))
     '(begin  . (lambda (exp env) (eval-sequence (begin-actions exp) env)))
     '(cond   . (derived-exp cond->if))
     '(and    . eval-and)
     '(or     . eval-or)
     '(let    . (derived-exp let->combination))))
#+end_src

#+NAME: eval_dispatch
#+begin_src scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((pair? exp)
           (let ((operator (car exp))
                 (operands (cdr exp)))
             (let ((special-form (assq-ref operator special-forms)))
               (if (special-form)
                   (special-form operands env)
                   (apply (eval operator env)
                          (list-of-values operands env))))))
          (else (error "Unknown expression type -- EVAL"))))
#+end_src

*Exercise 4.4*. Recall the definitions of the special forms ~and~ and ~or~ from Chapter 1:::

  * ~and~: The expressions are evaluated from left to right.  If any expression evaluates to false, false is returned; any remaining expressions are not evaluated.  If all the expressions evaluate to true values, the value of the last expression is returned.  If there are no expressions then true is returned.

  * ~or~: The expressions are evaluated from left to right.  If any expression evaluates to a true value, that value is returned; any remaining expressions are not evaluated.  If all expressions evaluate to false, or if there are no expressions, then false is returned.

Install ~and~ and ~or~ as new special forms for the evaluator by defining appropriate syntax procedures and evaluation procedures ~eval-and~ and ~eval-or~.  Alternatively, show how to implement ~and~ and ~or~ as derived expressions.

#+NAME: and_or_special
#+begin_src scheme
  ;; as special forms (add these to special forms list)
  (define (eval-and exp env)
    (if (null? exp)
        true
        (let ((value (eval (car exp) env)))
          (if (false? value)
              false
              (if (null? (cdr exp))
                  value
                  (eval-and (cdr exp) env))))))

  (define (eval-or exp env)
    (if (null? exp)
        false
        (let ((value (eval (car exp) env)))
          (if (true? value)
              value
              (eval-or (cdr exp) env)))))
#+end_src

#+NAME: and_or_derived
#+begin_src scheme
  ;; as derived expressions
  (define (eval-and exp env) (eval (and->if exp) env))
  (define (eval-or exp env) (eval (or->if exp) env))

  ;; an example of and turned into a derived expression of ifs
  ;; (and a b c) =>
  ;; (if (null? exp)
  ;;     'true
  ;;     (if (a)
  ;;         (if (b)
  ;;             (if (c)
  ;;                 c
  ;;                 'false)
  ;;             'false)
  ;;         'false))
  ;; (or a b c) =>
  ;; (if (null? exp)
  ;;     'false
  ;;     (if (a)
  ;;         a
  ;;         (if (b)
  ;;             b
  ;;             (if (c)
  ;;                 c
  ;;                 'false))))

  (define (and->if exp)
    (expand-and-clauses (cdr exp)))

  (define (expand-and-clauses clauses)
    (if (null? clauses)
        'true
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (make-if first
                   (if (null? rest)
                       first
                       (expand-and-clauses rest))))))

  (define (or->if exp)
    (expand-or-clauses (cdr exp)))

  (define (expand-or-clauses clauses)
    (if (null? clauses)
        'false
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (make-if first (expand-or-clauses rest)))))
#+end_src

*Exercise 4.5*. Scheme allows an additional syntax for ~cond~ clauses, ~(<TEST> => <RECIPIENT>)~.  If <TEST> evaluates to a true value, then <RECIPIENT> is evaluated.  Its value must be a procedure of one argument; this procedure is then invoked on the value of the <TEST>, and the result is returned as the value of the ~cond~ expression.  For example

#+begin_src scheme
  (cond ((assoc 'b '((a 1) (b 2))) => cadr)
        (else false))
#+end_src

returns 2.  Modify the handling of ~cond~ so that it supports this extended syntax.

#+NAME: cond_new
#+begin_src scheme
  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  ;; (cond a b c) =>
  ;; (if (null? exp)
  ;;     'false
  ;;     ;; ((lambda (x)
  ;;     ;;    (if (x)
  ;;     ;;        (if (eq? (car actions) '=>)
  ;;     ;;            ((cdr actions) x)
  ;;     ;;            x)
  ;;     ;;        (lambda (y)
  ;;     ;;          (if (y)
  ;;     ;;              (if (eq? (car)))))))
  ;;     ;;  (cond-predicate a))
  ;;     (if (cond-predicate a)
  ;;         (sequence->exp (cond-actions a))
  ;;         (if (cond-predicate b)
  ;;             (sequence->exp (cond-actions b))
  ;;             (if (cond-predicate c)
  ;;                 (sequence->exp (cond-actions b))
  ;;                 'false))))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false                          ; no `else' clause
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last -- COND->IF"
                         clauses))
              (let ((pred (cond-predicate first))
                    (actions (cond-actions first)))
                (make-cond-clause pred actions rest))))))

  (define (make-cond-type actions pred-var)
    (if (eq? (car actions) '=>)
        (list (cdr actions) 'x)
        (sequence->exp actions)))

  (define (make-cond-clause pred actions rest)
    (list (make-lambda 'x
                       (make-if 'x
                                (make-cond-type actions 'x)
                                (expand-clauses rest)))
          pred))
#+end_src

*Exercise 4.6*. ~Let~ expressions are derived expressions, because

#+begin_src scheme
  (let ((<VAR_1> <EXP_1>) ... (<VAR_N> <EXP_N>))
    <BODY>)
#+end_src

is equivalent to

#+begin_src scheme
  ((lambda (<VAR_1> ... <VAR_N>)
     <BODY>)
   <EXP_1>
   ...
   <EXP_N>)
#+end_src

Implement a syntactic transformation ~let->combination~ that reduces evaluating ~let~ expressions to evaluating combinations of the type shown above, and add the appropriate clause to ~eval~ to handle ~let~ expressions.

#+begin_src scheme
  (define (let-vars var-exp)
    (if (null? var-exp)
        '()
        (cons (car var-exp) (let-vars (cdr var-exp)))))

  (define (let-exps var-exp)
    (if (null? var-exp)
        '()
        (cons (cadr var-exp) (let-exprs (cdr var-exp)))))

  (define (let-var-exp exp) (cadr exp))

  (define (let-body exp) (cddr exp))

  (define (let->combination exp)
    (list (make-lambda (let-vars (let-var-exp exp))
                       (let-body exp))
          (let-exps (let-var-exp exp))))
#+end_src

  * added to ~special-forms~

*Exercise 4.7*. ~Let*~ is similar to ~let~, except that the bindings of the ~let~ variables are performed sequentially from left to right, and each binding is made in an environment in which all of the preceding bindings are visible.  For example

#+begin_src scheme
  (let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))
#+end_src


returns 39.  Explain how a ~let*~ expression can be rewritten as a set of nested ~let~ expressions, and write a procedure ~let*->nested-lets~ that performs this transformation.  If we have already implemented ~let~ (*Note Exercise 4-6::) and we want to extend the evaluator to handle ~let*~, is it sufficient to add a clause to ~eval~ whose action is

#+begin_src scheme
  (eval (let*->nested-lets exp) env)
#+end_src

or must we explicitly expand ~let*~ in terms of non-derived expressions?

#+begin_src scheme
(let* ((<VAR_1> <EXP_1>) ... (<VAR_N> <EXP_N>))
  <BODY>)
#+end_src

#+begin_src scheme
(let ((VAR_1 EXP_1))
  (let ((VAR_2 EXP_1))
    ...
    (let ((VAR_N EXP_N)))
      <BODY>))
#+end_src

#+begin_src scheme
  (define (make-let var-exps body)
    (list 'let var-exps body))

  (define (let*->nested-lets exp)
    (define (expand-let-clauses var-exps)
      (if (null? var-exps)
          (let-body exp)
          (make-let (list (car var-exps))
                    (expand-let-clauses (cdr var-exps)))))
    (expand-let-clauses (let-var-exp exp)))
#+end_src

  * it should be sufficient to just define ~let*~ in terms of *let*, since ~let~ will in turn be expanded by the evaluator.

*Exercise 4.8*. "Named ~let~" is a variant of ~let~ that has the form

#+begin_src scheme
  (let <VAR> <BINDINGS> <BODY>)
#+end_src

The <BINDINGS> and <BODY> are just as in ordinary ~let~, except that <VAR> is bound within <BODY> to a procedure whose body is <BODY> and whose parameters are the variables in the <BINDINGS>. Thus, one can repeatedly execute the <BODY> by invoking the procedure named <VAR>.  For example, the iterative Fibonacci procedure (section *Note 1-2-2::) can be rewritten using named ~let~ as follows:

#+begin_src scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
#+end_src


Modify ~let->combination~ of *Note Exercise 4-6:: to also support named ~let~.

#+begin_src scheme

#+end_src
