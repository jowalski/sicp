# -*- org-babel-use-quick-and-dirty-noweb-expansion: t; -*-
#+FILETAGS: @personal
#+LaTeX_HEADER: \newcommand{\mya}[2]{ ( A\, #1\, #2) }
#+LaTeX_HEADER: \usepackage{forest}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \newcommand{\leaf}[3]{{(cc #1 #2)\\[-1ex]\scriptsize #3}}
* Exercises for the Structure and Interpretation of Computer Languages
:PROPERTIES:
:header-args: :results silent :noweb yes
:header-args: :noweb yes
:END:
** 4 Metalinguistic Abstraction
The evaluator, which determines the meaning of expressions in a programming language, is just another program. In fact any program can be viewed as the evaluator for some language, like our polynomial manipulation system, or digital-logic simulator.
*** 4.1 The Metacircular Evaluator
We will implement our evaluator in Lisp, the same language the evaluator evaluates, thus it is "metacircular".

This will be a scheme formulation of the environment model of evaluation:

1. To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions.

2. To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment.  To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to which the procedure is applied.
**** 4.1.1 The Core of the Evaluator
The evaluation process can be described as the interplay between two procedures: ~eval~ and ~apply~.
***** Eval
See SICP for details, the definition of ~eval~ is a case analysis using ~cond~:

#+NAME: eval
#+begin_src scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Unknown expression type -- EVAL" exp))))
#+end_src

A disadvantage of using a case analysis is that no new types of expressions can be defined without editing the definition of ~eval~. In other Lisp implementations, dispatching is done in data-directed style that allows addition without modification of ~eval~.
***** Apply
~apply~ takes two arguments, a procedure and list of arguments. It classifies procedures into primitives and compound procedures.

#+NAME: apply
#+begin_src scheme
  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
             (procedure-body procedure)
             (extend-environment
               (procedure-parameters procedure)
               arguments
               (procedure-environment procedure))))
          (else
           (error
            "Unknown procedure type -- APPLY" procedure))))
#+end_src
***** Procedure arguments
#+NAME: list_of_values
#+begin_src scheme
  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
        (cons (eval (first-operand exps) env)
              (list-of-values (rest-operands exps) env))))
#+end_src
***** Conditionals
#+NAME: eval_if
#+begin_src scheme
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))
#+end_src
Note how ~true?~ works, it translates a value in the languages being implemented to a (boolean) value in the implementation language. "The metacircular representation of truth might not be the same as that of the underlying Scheme."

***** Sequences
#+NAME: eval_sequence
#+begin_src scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+end_src

***** Assignments and definitions
#+NAME: eval_assignment
#+begin_src scheme
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    'ok)
#+end_src

#+NAME: eval_definition
#+begin_src scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
                      (eval (definition-value exp) env)
                      env)
    'ok)
#+end_src

*Exercise 4.1*. Notice that we cannot tell whether the metacircular evaluator evaluates operands from left to right or from right to left.  Its evaluation order is inherited from the underlying Lisp: If the arguments to ~cons~ in ~list-of-values~ are evaluated from left to right, then ~list-of-values~ will evaluate operands from left to right; and if the arguments to ~cons~ are evaluated from right to left, then ~list-of-values~ will evaluate operands from right to left.

Write a version of ~list-of-values~ that evaluates operands from left to right regardless of the order of evaluation in the underlying Lisp.  Also write a version of ~list-of-values~ that evaluates operands from right to left.

#+begin_src scheme
  (define (list-of-values-l-to-r exps env)
    (if (no-operands? exps)
        '()
        (let ((first-evalled (eval (first-operand exps) env)))
          (cons first-evalled
                (list-of-values-l-to-r (rest-operands exps) env)))))

  (define (list-of-values-r-to-l exps env)
    (if (no-operands? exps)
        '()
        (let ((rest-evalled
               (list-of-values-r-to-l (rest-operands exps) env)))
          (cons (eval (first-operand exps) env)
                rest-evalled))))
#+end_src

**** 4.1.2 Representing Expressions
The evaluator is similar to the symbolic differentiation program in [[file:exercises-1-2.org::*2.3.2%20Example:%20Symbolic%20Differentiation][2-3-2]].
  * Both operate on symbolic expressions
  * the result of operating on a compound expression is determined by operating recursively on its parts, and combining them in a way dependent on the types of the expression
  * We've decoupled the rules of operation from the details of representation.

Below is the specification of the syntax of the language:

#+NAME: syntax
#+begin_src scheme
  ;; self-evaluating items
  (define (self-evaluating? exp)
    (cond ((number? exp) #t)
          ((string? exp) #t)
          (else #f)))

  ;; variables
  (define (variable? exp) (symbol? exp))

  ;; quotations
  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))


  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))

  ;; assignments
  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  ;; definitions
  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)   ; formal parameters
                     (cddr exp)))) ; body

  ;; lambda expressions
  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  ;; conditionals
  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  ;; begin expressions
  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  ;; procedure applications
  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))
#+end_src

***** Derived expressions
We define ~cond~ in terms of other special forms, rather than creating another special form.

#+NAME: cond
#+begin_src scheme
  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false                          ; no `else' clause
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last -- COND->IF"
                         clauses))
              (make-if (cond-predicate first)
                       (sequence->exp (cond-actions first))
                       (expand-clauses rest))))))
#+end_src

~let~ is another derived expression we will implement.

*Exercise 4.2*. Louis Reasoner plans to reorder the ~cond~ clauses in ~eval~ so that the clause for procedure applications appears before the clause for assignments.  He argues that this will make the interpreter more efficient: Since programs usually contain more applications than assignments, definitions, and so on, his modified ~eval~ will usually check fewer clauses than the original ~eval~ before identifying the type of an expression.

a. What is wrong with Louis's plan?  (Hint: What will Louis's evaluator do with the expression ~(define x 3)~?)

It will interpret the 'define expression as a procedure application, and attempt to apply 'define to '(x 3), which will presumably result in some type of error (we haven't defined exactly what because ~lookup-variable-value~ is undefined now).

As written:
  * (eval '(define x 3) env)
  * (cond ... ((definition? '(define x 3)) (eval-definition '(define x 3) env)) ...)
  * (define-variable! (definition-variable exp) (eval (definition-value exp) env) env)
  * (define-variable 'x (eval 3 env) env)

Putting procedure applications before assignments:
  * (eval '(define x 3) env)
  * (cond ...((application? '(define x 3)) (apply (eval ...) (list-of-values ...))))
  * (apply (eval 'define env) (list-of-values '(x 3) env))
  * (apply (lookup-variable-value 'define env) ...)
  * some type of error where 'define is not defined or reserved?

b. Louis is upset that his plan didn't work.  He is willing to go to any lengths to make his evaluator recognize procedure applications before it checks for most other kinds of expressions.  Help him by changing the syntax of the evaluated language so that procedure applications start with ~call~.  For example, instead of ~(factorial 3)~ we will now have to write ~(call factorial 3)~ and instead of ~(+ 1 2)~ we will have to write ~(call + 1 2)~.

#+begin_src scheme
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
#+end_src

*Exercise 4.3*. Rewrite ~eval~ so that the dispatch is done in data-directed style.  Compare this with the data-directed differentiation procedure of Exercise 2-73::.  (You may use the ~car~ of a compound expression as the type of the expression, as is appropriate for the syntax implemented in this section.)

#+NAME: special_forms
#+begin_src scheme
  (define (derived-exp exp-f)
    (lambda (exp env) (eval (exp-f exp) env)))

  (define special-forms
    (list
     `(quote  . ,(lambda (exp env) (text-of-quotation exp)))
     `(set!   . ,eval-assignment)
     `(define . ,eval-definition)
     `(if     . ,eval-if)
     `(lambda . ,(lambda (exp env)
                   (make-procedure (lambda-parameters exp)
                                   (lambda-body exp) env)))
     `(begin  . ,(lambda (exp env) (eval-sequence (begin-actions exp) env)))
     `(cond   . ,(derived-exp cond->if))
     `(and    . ,(eval-list-f eval-and))
     `(or     . ,(eval-list-f eval-or))
     `(let    . ,(derived-exp let->combination))))
#+end_src

#+NAME: eval_dispatch
#+begin_src scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((pair? exp)
           (let ((operator (car exp)))
             (let ((special-form (assq-ref special-forms operator)))
               (if special-form
                   (special-form exp env)
                   (apply (eval operator env)
                          (list-of-values (cdr exp) env))))))
          (else (error "Unknown expression type -- EVAL"))))
#+end_src

*Exercise 4.4*. Recall the definitions of the special forms ~and~ and ~or~ from Chapter 1:::

  * ~and~: The expressions are evaluated from left to right.  If any expression evaluates to false, false is returned; any remaining expressions are not evaluated.  If all the expressions evaluate to true values, the value of the last expression is returned.  If there are no expressions then true is returned.

  * ~or~: The expressions are evaluated from left to right.  If any expression evaluates to a true value, that value is returned; any remaining expressions are not evaluated.  If all expressions evaluate to false, or if there are no expressions, then false is returned.

Install ~and~ and ~or~ as new special forms for the evaluator by defining appropriate syntax procedures and evaluation procedures ~eval-and~ and ~eval-or~.  Alternatively, show how to implement ~and~ and ~or~ as derived expressions.

#+NAME: and_or_special
#+begin_src scheme
  (define (eval-list-f f) (lambda (exp env) (f (cdr exp) env)))

  (define (eval-and exp env)
    (if (null? exp)
        #t
        (let ((value (eval (car exp) env)))
          (if (false? value)
              #f
              (if (null? (cdr exp))
                  value
                  (eval-and (cdr exp) env))))))

  (define (eval-or exp env)
    (if (null? exp)
        #f
        (let ((value (eval (car exp) env)))
          (if (true? value)
              value
              (eval-or (cdr exp) env)))))
#+end_src

#+NAME: and_or_derived
#+begin_src scheme
  ;; as derived expressions
  (define (eval-and exp env) (eval (and->if exp) env))
  (define (eval-or exp env) (eval (or->if exp) env))

  ;; an example of and turned into a derived expression of ifs
  ;; (and a b c) =>
  ;; (if (null? exp)
  ;;     'true
  ;;     (if (a)
  ;;         (if (b)
  ;;             (if (c)
  ;;                 c
  ;;                 'false)
  ;;             'false)
  ;;         'false))
  ;; (or a b c) =>
  ;; (if (null? exp)
  ;;     'false
  ;;     (if (a)
  ;;         a
  ;;         (if (b)
  ;;             b
  ;;             (if (c)
  ;;                 c
  ;;                 'false))))

  (define (and->if exp)
    (expand-and-clauses (cdr exp)))

  (define (expand-and-clauses clauses)
    (if (null? clauses)
        'true
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (make-if first
                   (if (null? rest)
                       first
                       (expand-and-clauses rest))))))

  (define (or->if exp)
    (expand-or-clauses (cdr exp)))

  (define (expand-or-clauses clauses)
    (if (null? clauses)
        'false
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (make-if first (expand-or-clauses rest)))))
#+end_src

*Exercise 4.5*. Scheme allows an additional syntax for ~cond~ clauses, ~(<TEST> => <RECIPIENT>)~.  If <TEST> evaluates to a true value, then <RECIPIENT> is evaluated.  Its value must be a procedure of one argument; this procedure is then invoked on the value of the <TEST>, and the result is returned as the value of the ~cond~ expression.  For example

#+begin_src scheme
  (cond ((assoc 'b '((a 1) (b 2))) => cadr)
        (else #f))
#+end_src

returns 2.  Modify the handling of ~cond~ so that it supports this extended syntax.

#+NAME: cond_new
#+begin_src scheme
  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  ;; (cond a b c) =>
  ;; (if (null? exp)
  ;;     'false
  ;;     ;; ((lambda (x)
  ;;     ;;    (if (x)
  ;;     ;;        (if (eq? (car actions) '=>)
  ;;     ;;            ((cdr actions) x)
  ;;     ;;            x)
  ;;     ;;        (lambda (y)
  ;;     ;;          (if (y)
  ;;     ;;              (if (eq? (car)))))))
  ;;     ;;  (cond-predicate a))
  ;;     (if (cond-predicate a)
  ;;         (sequence->exp (cond-actions a))
  ;;         (if (cond-predicate b)
  ;;             (sequence->exp (cond-actions b))
  ;;             (if (cond-predicate c)
  ;;                 (sequence->exp (cond-actions b))
  ;;                 'false))))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false                          ; no `else' clause
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last -- COND->IF"
                         clauses))
              (let ((pred (cond-predicate first))
                    (actions (cond-actions first)))
                (if (eq? (car actions) '=>)
                    (cons (make-lambda '(x)
                                       (list
                                         (make-if 'x (list (cadr actions) 'x)
                                                      (expand-clauses rest))))
                          (list pred))
                    (make-if (cond-predicate first)
                             (sequence->exp (cond-actions first))
                             (expand-clauses rest))))))))

#+end_src

*Exercise 4.6*. ~Let~ expressions are derived expressions, because

#+begin_src scheme
  (let ((<VAR_1> <EXP_1>) ... (<VAR_N> <EXP_N>))
    <BODY>)
#+end_src

is equivalent to

#+begin_src scheme
  ((lambda (<VAR_1> ... <VAR_N>)
     <BODY>)
   <EXP_1>
   ...
   <EXP_N>)
#+end_src

Implement a syntactic transformation ~let->combination~ that reduces evaluating ~let~ expressions to evaluating combinations of the type shown above, and add the appropriate clause to ~eval~ to handle ~let~ expressions.

#+NAME: let
#+begin_src scheme
  (define (let-vars var-exp)
    (if (null? var-exp)
        '()
        (cons (caar var-exp) (let-vars (cdr var-exp)))))

  (define (let-exps var-exp)
    (if (null? var-exp)
        '()
        (cons (cadar var-exp) (let-exps (cdr var-exp)))))

  (define (let-var-exp exp) (cadr exp))

  (define (let-body exp) (cddr exp))


#+end_src

#+NAME: let_plain
#+begin_src scheme
  (define (let->combination exp)
    (cons (make-lambda (let-vars (let-var-exp exp))
                       (let-body exp))
          (let-exps (let-var-exp exp))))
#+end_src

  * added to ~special-forms~

*Exercise 4.7*. ~Let*~ is similar to ~let~, except that the bindings of the ~let~ variables are performed sequentially from left to right, and each binding is made in an environment in which all of the preceding bindings are visible.  For example

#+begin_src scheme
  (let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))
#+end_src


returns 39.  Explain how a ~let*~ expression can be rewritten as a set of nested ~let~ expressions, and write a procedure ~let*->nested-lets~ that performs this transformation.  If we have already implemented ~let~ (*Note Exercise 4-6::) and we want to extend the evaluator to handle ~let*~, is it sufficient to add a clause to ~eval~ whose action is

#+begin_src scheme
  (eval (let*->nested-lets exp) env)
#+end_src

or must we explicitly expand ~let*~ in terms of non-derived expressions?

#+begin_src scheme
(let* ((<VAR_1> <EXP_1>) ... (<VAR_N> <EXP_N>))
  <BODY>)
#+end_src

#+begin_src scheme
(let ((VAR_1 EXP_1))
  (let ((VAR_2 EXP_1))
    ...
    (let ((VAR_N EXP_N)))
      <BODY>))
#+end_src

#+NAME: let_plus
#+begin_src scheme
  (define (make-let var-exps body)
    (cons 'let (cons var-exps body)))

  (define (let*->nested-lets exp)
    (define (expand-let-clauses var-exps)
      (if (null? var-exps)
          (let-body exp)
          (make-let (list (car var-exps))
                    (expand-let-clauses (cdr var-exps)))))
    (expand-let-clauses (let-var-exp exp)))
#+end_src

  * it should be sufficient to just define ~let*~ in terms of *let*, since ~let~ will in turn be expanded by the evaluator.

*Exercise 4.8*. "Named ~let~" is a variant of ~let~ that has the form

#+begin_src scheme
  (let <VAR> <BINDINGS> <BODY>)
#+end_src

The <BINDINGS> and <BODY> are just as in ordinary ~let~, except that <VAR> is bound within <BODY> to a procedure whose body is <BODY> and whose parameters are the variables in the <BINDINGS>. Thus, one can repeatedly execute the <BODY> by invoking the procedure named <VAR>.  For example, the iterative Fibonacci procedure (section *Note 1-2-2::) can be rewritten using named ~let~ as follows:

#+begin_src scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
#+end_src

Modify ~let->combination~ of *Note Exercise 4-6:: to also support named ~let~.

The equivalent (I think) would be:

#+begin_src scheme
  ((lambda ()
     (define <VAR> (lambda (<VAR_1> ... <VAR_N>)
                    <BODY>))
     (<VAR> <EXP_1> ... <EXP_N>)))
#+end_src

#+NAME: enclose_body
#+begin_src scheme
(define (enclose-body body) (list (make-lambda '() body)))
#+end_src

#+NAME: make_definition
#+begin_src scheme
(define (make-value-definition var value)
  (list 'define var value))
(define (make-fun-definition var args body)
  (list 'define (list var args) body))
#+end_src

#+NAME: let_named
#+begin_src scheme
  <<enclose_body>>
  <<make_definition>>
  (define (named-let-var exp) (cadr exp))
  (define (named-let-vars exp) (let-vars (caddr exp)))
  (define (named-let-exps exp) (let-exps (caddr exp)))
  (define (named-let-body exp) (cdddr exp))

  (define (make-named-let var vars exps body)
    (enclose-body
     (list (make-value-definition var
             (make-lambda vars body))
           (cons var exps))))

  (define (let->combination exp)
    (if (symbol? (cadr exp))
        (make-named-let (named-let-var exp)     ; named let
                        (named-let-vars exp)
                        (named-let-exps exp)
                        (named-let-body exp))
        (cons (make-lambda (let-vars (let-var-exp exp)) ; regular let
                           (let-body exp))
              (let-exps (let-var-exp exp)))))
#+end_src

*Exercise 4.9*. Many languages support a variety of iteration constructs, such as ~do~, ~for~, ~while~, and ~until~.  In Scheme, iterative processes can be expressed in terms of ordinary procedure calls, so special iteration constructs provide no essential gain in computational power.  On the other hand, such constructs are often convenient.  Design some iteration constructs, give examples of their use, and show how to implement them as derived expressions.

  * starting with the GUILE do

#+begin_src scheme
(do ((<VAR_1> <INIT_1> <STEP_1>) ...) (<TEST> [<EXP>]) <BODY> )
#+end_src

#+begin_src scheme
((lambda ()
   (define (*iter* var1 ...)
     (if (test)
         (begin body (*iter* (step1 var1) ...))
         exp))
   (*iter* init_1 ...)))
#+end_src

#+NAME: do
#+begin_src scheme
  <<enclose_body>>
  <<make_definition>>
  (define (do-var-clause exp) (cadr exp))
  (define (make-varlist clause part)
      (if (null? clause)
          '()
          (cons (part (car clause)) (make-varlist (cdr clause)))))

  (define (do-vars exp) (make-varlist (do-var-clause exp) car))
  (define (do-inits exp) (make-varlist (do-var-clause exp) cadr))
  (define (do-steps exp) (make-varlist (do-var-clause exp) caddr))

  (define (do-test exp) (car (caddr exp)))
  (define (do-exp exp)  (cadr (caddr exp)))
  (define (do-body exp) (cadddr exp))

  (define (do->combination exp)
    (enclose-body
     (list
      (make-fun-definition
       '*iter* (do-vars exp)
       (make-if (do-test exp)
                (make-begin
                 (do-body exp)
                 (list '*iter* (zip (do-steps) (do-vars exp))))
                (do-exp exp)))
      (append '*iter* (do-inits exp)))))
#+end_src

  * ~while~ (but without the ~break/continue~ functionality presumably)

#+begin_src scheme
  (while cond body)
#+end_src

#+begin_src scheme
  ((lambda ()
     (define (*iter*)
       (if (test)
           (begin body (*iter*))
           false))
     (*iter*)))
#+end_src

#+NAME: while
#+begin_src scheme
  (define (while-test exp) (cadr exp))
  (define (while-body exp) (caddr exp))

  (define (while->combination exp)
    (enclose-body
     (list
      (make-fun-definition
       '*iter* '()
       (make-if (while-test exp)
                (make-begin
                 (while-body exp)
                 (list '*iter*))
                #f))
      (list '*iter*))))

#+end_src

*Exercise 4.10*. By using data abstraction, we were able to write an ~eval~ procedure that is independent of the particular syntax of the language to be evaluated.  To illustrate this, design and implement a new syntax for Scheme by modifying the procedures in this section, without changing ~eval~ or ~apply~.

  * we could rename the special forms, change the order of arguments to each form
  * not sure what else we could easily do???

**** 4.1.3 Evaluator Data Structures
We also need to implement the internal data structures that the evaluator manipulates.
***** Testing of predicates
For conditionals, anything is true that isn't the explicit ~false~ object.

#+NAME: bool
#+begin_src scheme
  (define (true? x)
    (not (eq? x #f)))

  (define (false? x)
    (eq? x #f))
#+end_src
***** Representing procedures

Later we'll describe ~apply-primitive-procedure~ and ~primitive-procedure?~.

#+NAME: procedures
#+begin_src scheme
  (define (make-procedure parameters body env)
    (list 'procedure parameters (scan-out-defines body) env))

  (define (compound-procedure? p)
    (tagged-list? p 'procedure))

  (define (procedure-parameters p) (cadr p))

  (define (procedure-body p) (caddr p))

  (define (procedure-environment p) (cadddr p))
#+end_src
***** Operations on Environments
To manipulate environments we need ~lookup-variable-value~, ~extend-environment~, ~define-variable!~ and ~set-variable-value!~.

We'll represent an environment as a list of frames.

#+NAME: environment_funs
#+begin_src scheme
  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))
#+end_src

To extend an environment by a new frame, we make a frame of the list of variables and values and adjoin it to the environment:

#+NAME: environment_manip
#+begin_src scheme
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Too many arguments supplied" vars vals)
            (error "Too few arguments supplied" vars vals))))

  ;; (define (lookup-variable-value var env)
  ;;   (define (env-loop env)
  ;;     (define (scan vars vals)
  ;;       (cond ((null? vars)
  ;;              (env-loop (enclosing-environment env)))
  ;;             ((eq? var (car vars))
  ;;              (car vals))
  ;;             (else (scan (cdr vars) (cdr vals)))))
  ;;     (if (eq? env the-empty-environment)
  ;;         (error "Unbound variable" var)
  ;;         (let ((frame (first-frame env)))
  ;;           (scan (frame-variables frame)
  ;;                 (frame-values frame)))))
  ;;   (env-loop env))

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Unbound variable -- SET!" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
            (frame-values frame))))
#+end_src

*Exercise 4.11*. Instead of representing a frame as a pair of lists, we can represent a frame as a list of bindings, where each binding is a name-value pair.  Rewrite the environment operations to use this alternative representation.

#+NAME: frame_bindings
#+begin_src scheme
  (define (make-frame variables values)
    (if (null? variables)
        '()
        (cons (cons (car variables) (car values))
              (make-frame (cdr variables) (cdr values)))))

  (define (frame-variables frame)
    (if (null? frame)
        '()
        (cons (caar frame) (frame-variables (cdr frame)))))

  (define (frame-values frame)
    (if (null? frame)
        '()
        (cons (cadar frame) (frame-values (cdr frame)))))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var val)))
#+end_src

*Exercise 4.12*. The procedures ~set-variable-value!~, ~define-variable!~, and ~lookup-variable-value~ can be expressed in terms of more abstract procedures for traversing the environment structure.  Define abstractions that capture the common patterns and redefine the three procedures in terms of these abstractions.

#+begin_src scheme
  (define (traverse-env var env on-match . on-null)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (if (null? on-null)
                   (env-loop (enclosing-environment env))
                   (on-null env)))
              ((eq? var (car vars))
               (on-match vars vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Unbound variable" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (lookup-variable-value var env)
    (traverse-env var env car))

  (define (set-variable-value! var val env)
    (traverse-env var env
                  (lambda (vals) (set-car! vals val))))

  (define (define-variable! var val env)
    (traverse-env var env
                  (lambda (vals) (set-car! vals val))
                  (lambda (env) (add-binding-to-frame! var val (first-frame env)))))
#+end_src


*Exercise 4.13*. Scheme allows us to create new bindings for variables by means of ~define~, but provides no way to get rid of bindings.  Implement for the evaluator a special form ~make-unbound!~ that removes the binding of a given symbol from the environment in which the ~make-unbound!~ expression is evaluated. This problem is not completely specified.  For example, should we remove only the binding in the first frame of the environment? Complete the specification and justify any choices you make.

#+begin_src scheme
  (define (remove-cons x)
    (begin (set-car! x (cadr x))
           (set-cdr! x (cddr x))))

  (define (make-unbound! var env)
    (traverse-env sym env
                  (lambda (vars vals)
                    (if (null? (cdr vars)) ; only one element in vars
                        (begin (set-car! (first-frame env) (cdr vars))
                               (set-cdr! (first-frame env) (cdr vals)))
                        (begin (remove-cons vars)
                               (remove-cons vals))))
                  (lambda () (error "Could not find " var))))
#+end_src

  * This only removes the binding in the first frame. One reason for this choice is because you can only ~define-variable!~ in the first frame of the environment, so in this sense it is symmetrical. You can also still call ~make-unbound!~ on the enclosed environment if you'd like to unbind a variable there.
** 4.1.4 Running the Evaluator as a Program
The evaluator reduces expressions to the application of primitive procedures, so we need a binding for each primitive procedure. We create a global environment that contains these names, as well as for ~true~ and ~false~.

#+NAME: environment
#+begin_src scheme
  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true #t initial-env)
      (define-variable! 'false #f initial-env)
      initial-env))

  ;; (define the-global-environment (setup-environment))
#+end_src

It doesn't matter how we represent primitive procedures, so long as ~apply~ can identify and apply them, so we'll implement them as a list beginning with ~primitive~ and containing a procedure in the underlying lisp that implements the procedure.

#+NAME: primitive_funs
#+begin_src scheme
  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))

  (define (primitive-implementation proc) (cadr proc))
#+end_src

#+NAME: primitives
#+begin_src scheme
  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cons cons)
          (list 'null? null?)
          ;; <MORE PRIMITIVES>
          ))

  (define (primitive-procedure-names)
    (map car
         primitive-procedures))

  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
         primitive-procedures))

  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))

  (define apply-in-underlying-scheme apply)
#+end_src

This is a "driver loop" that models the read-eval-print loop of the underlying Lisp system.

#+NAME: driver_loop
#+begin_src scheme
  (define input-prompt ";;; M-Eval input: ")
  (define output-prompt ";;; M-Eval value: ")

  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define (prompt-for-input string)
    (newline) (display string))

  (define (announce-output string)
    (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>))
        (display object)))
   (define the-global-environment (setup-environment))
#+end_src

To run the evaluator we just initialize the global environment and start the loop:

#+NAME: run_scheme
#+begin_src scheme
  <<evaluator_package>>

  (driver-loop)
#+end_src

#+NAME: evaluator_package
#+begin_src scheme :tangle evaluator.scm
  <<list_of_values>>
  <<eval_if>>
  <<eval_sequence>>
  <<eval_assignment>>
  <<eval_definition>>
  <<syntax>>
  <<and_or_special>>
  ;; <<and_or_derived>>
  <<cond_new>>
  <<let>>
  <<let_plus>>
  <<enclose_body>>
  <<make_definition>>
  <<let_named>>
  <<bool>>
  <<procedures>>
  <<special_forms>>
  <<environment_funs>>
  <<environment_manip>>
  <<environment>>
  <<primitives>>
  <<primitive_funs>>
  <<apply>>
  <<eval_dispatch>>
  <<driver_loop>>
  <<lookup_variable_value>>
  <<scan_out_defines>>
#+end_src

*Exercise 4.14*. Eva Lu Ator and Louis Reasoner are each experimenting with the metacircular evaluator.  Eva types in the definition of ~map~, and runs some test programs that use it. They work fine.  Louis, in contrast, has installed the system version of ~map~ as a primitive for the metacircular evaluator. When he tries it, things go terribly wrong.  Explain why Louis's ~map~ fails even though Eva's works.

The underlying Lisp ~map~ takes as its function arguments a function of the underlying Lisp type. So it may work with functions that themselves are primitives, but for non-primitives, it will essentially be getting something else (a list representing a function in the implemented Lisp, )
** 4.1.5 Data as Programs
*Exercise 4.15*. Given a one-argument procedure ~p~ and an object ~a~, ~p~ is said to "halt" on ~a~ if evaluating the expression ~(p a)~ returns a value (as opposed to terminating with an error message or running forever).  Show that it is impossible to write a procedure ~halts?~ that correctly determines whether ~p~ halts on ~a~ for any procedure ~p~ and object ~a~.  Use the following reasoning: If you had such a procedure ~halts?~, you could implement the following program:

#+begin_src scheme
  (define (run-forever) (run-forever))

  (define (try p)
    (if (halts? p p)
        (run-forever)
        'halted))
#+end_src

Now consider evaluating the expression ~(try try)~ and show that any possible outcome (either halting or running forever) violates the intended behavior of ~halts?~.

  * if we run ~(try try)~ and it halts, then it implies one of either of the consequents of the ~if~ expression ran (because we're assuming an error was not possible). If it's 'halted, that implies ~(halts? try try)~ was false, which means ~halts?~ doesn't do what we said it does. And it can't be ~(run-forever)~ because that itself doesn't halt.
  * if we run ~(try try)~ and it doesn't halt (which we'll never really know in fact if it does), then it implies the consequent of the ~if~ expression could not have been 'halted, so ~(halts? p p)~ must have been true, which again implies ~halts?~ doesn't do what it says it does.
** 4.1.6 Internal Definitions
We want to treat internal definitions as having simultaneous scope, e.g.

#+begin_src scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    <REST OF BODY OF `F'>)
#+end_src

It shouldn't matter if the <REST OF BODY> comes before, after or in between ~odd?~ and ~even~. We can do this by "scanning out" and eliminating internal definitions in the body. So:

#+begin_src scheme
  (lambda <VARS>
    (define u <E1>)
    (define v <E2>)
    <E3>)
#+end_src

becomes:

#+begin_src scheme
  (lambda <VARS>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <E1>)
      (set! v <E2>)
      <E3>))
#+end_src

*Exercise 4.16*. In this exercise we implement the method just described for interpreting internal definitions.  We assume that the evaluator supports ~let~ (see *Note Exercise 4-6::).

a. Change ~lookup-variable-value~ (section *Note 4-1-3::) to signal an error if the value it finds is the symbol ~*unassigned*~.

#+NAME: lookup_variable_value
#+begin_src scheme
  (define (lookup-variable-value var env)
      (define (env-loop env)
        (define (scan vars vals)
          (cond ((null? vars)
                 (env-loop (enclosing-environment env)))
                ((eq? var (car vars))
                 (if (unassigned? (car vals))
                     (error "Variable unassigned" var)
                     (car vals)))
                (else (scan (cdr vars) (cdr vals)))))
        (if (eq? env the-empty-environment)
            (error "Unbound variable" var)
            (let ((frame (first-frame env)))
              (scan (frame-variables frame)
                    (frame-values frame)))))
      (env-loop env))

  (define (unassigned? val) (eq? val '*unassigned*))
#+end_src

b. Write a procedure ~scan-out-defines~ that takes a procedure body and returns an equivalent one that has no internal definitions, by making the transformation described above.

#+NAME: scan_out_defines
#+begin_src scheme
  (define (make-assignment var exp) (list 'set! var exp))

  (define (scan-out-defines body)
    (define (scan exps defs non-defs)
      (cond ((null? exps) (cons (reverse defs) (reverse non-defs)))
            ((definition? (car exps))
             (scan (cdr exps) (cons (car exps) defs) non-defs ))
            (else
             (scan (cdr exps) defs (cons (car exps) non-defs)))))
    (define (make-bindings def-exp)
      (list (definition-variable def-exp) '(quote *unassigned*)))
    (define (make-assign def-exp)
      (make-assignment (definition-variable def-exp)
                       (definition-value def-exp)))
    ;; scan => (defs non-defs)
    (let ((split-defines (scan body '() '())))
      (let ((defs (car split-defines))
            (non-defs (cdr split-defines)))
        (if (null? defs)
            body
            (list (make-let
                    (map make-bindings defs)
                    (append (map make-assign defs) non-defs)))))))
#+end_src

c. Install ~scan-out-defines~ in the interpreter, either in ~make-procedure~ or in ~procedure-body~ (see section 4-1-3::).  Which place is better?  Why?

  * ~procedure-body~ is called when we apply a procedure, each time, whereas ~make-procedure~ is called when we are evaluating a lambda, before it is applied.
  * I think calling it in ~make-procedure~, i.e. when the procedure is first encountered, would result in fewer calls to ~scan-out-defines~.
    * Say for example if the same procedure is being applied multiple times as in a ~map~ or ~filter~.

*Exercise 4.17*. Draw diagrams of the environment in effect when evaluating the expression <E3> in the procedure in the text, comparing how this will be structured when definitions are interpreted sequentially with how it will be structured if definitions are scanned out as described.  Why is there an extra frame in the transformed program?  Explain why this difference in environment structure can never make a difference in the behavior of a correct program.  Design a way to make the interpreter implement the "simultaneous" scope rule for internal definitions without constructing the extra frame.

  * The ~let~ statement is transformed into a ~lambda~, which when it is applied extends the environment with an additional frame containing its arguments ~u~ and ~v~.
  * This new environment is enclosed by the previous environment, so all names and their values are still accessible.
  * We could add the argument variables ~u~ and ~v~ to the existing environment instead, and ensure the ~set!~ statements are evaluated first in the body.

*Exercise 4.18*. Consider an alternative strategy for scanning out definitions that translates the example in the text to

#+begin_src scheme
  (lambda <VARS>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (let ((a <E1>)
            (b <E2>))
        (set! u a)
        (set! v b))
      <E3>))
#+end_src


Here ~a~ and ~b~ are meant to represent new variable names, created by the interpreter, that do not appear in the user's program. Consider the ~solve~ procedure from section *Note 3-5-4:::

#+begin_src scheme
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)
#+end_src

Will this procedure work if internal definitions are scanned out as shown in this exercise?  What if they are scanned out as shown in the text?  Explain.

In this exercise:

#+begin_src scheme
(lambda (f y0 dt)
  (let ((y '*unassigned*)
        (dy '*unassigned*))
    (let ((a (integral (delay dy) y0 dt))
          (b (stream-map f y)))
      (set! y a)
      (set! dy b))
    y))
#+end_src

In the text:

#+begin_src scheme
(lambda (f y0 dt)
  (let ((y '*unassigned*)
        (dy '*unassigned*))
    (set! y (integral (delay dy) y0 dt))
    (set! dy (stream-map f y))
    y))
#+end_src

  * I don't think this will work, because ~(stream-map f y)~ contains a non-delayed reference to y, which is not defined at the point in the assignment where it is assigned to ~b~.
  * The text scanning should work ok! (TODO: give better reason)

*Exercise 4.19*. Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about the desired result of evaluating the expression

#+begin_src scheme
  (let ((a 1))
    (define (f x)
      (define b (+ a x))
      (define a 5)
      (+ a b))
    (f 10))
#+end_src

Ben asserts that the result should be obtained using the sequential rule for ~define~: ~b~ is defined to be 11, then ~a~ is defined to be 5, so the result is 16.  Alyssa objects that mutual recursion requires the simultaneous scope rule for internal procedure definitions, and that it is unreasonable to treat procedure names differently from other names.  Thus, she argues for the mechanism implemented in *Note Exercise 4-16::.  This would lead to ~a~ being unassigned at the time that the value for ~b~ is to be computed.  Hence, in Alyssa's view the procedure should produce an error.  Eva has a third opinion.  She says that if the definitions of ~a~ and ~b~ are truly meant to be simultaneous, then the value 5 for ~a~ should be used in evaluating ~b~.  Hence, in Eva's view ~a~ should be 5, ~b~ should be 15, and the result should be 20.  Which (if any) of these viewpoints do you support?  Can you devise a way to implement internal definitions so that they behave as Eva prefers?(3)

  * Eva's is most consistent with the idea of simultaneous scope. (And guile seems to implement her option, btw, unlike MIT I guess.)
  *

#+begin_src scheme
  (let ((a 1))
    (define (f x)
      (let ((b '*unassigned*)
            (a '*unassigned*))
        (set! b (lambda () (+ a x)))
        (set! f-a (lambda () 5))
        (+ a b)
        )

      (define b (+ a x))
      (define a 5)
      )
    (f 10))
#+end_src
