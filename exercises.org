# -*- org-babel-use-quick-and-dirty-noweb-expansion: t; -*-
#+FILETAGS: @personal
#+LaTeX_HEADER: \newcommand{\mya}[2]{ ( A\, #1\, #2) }
#+LaTeX_HEADER: \usepackage{forest}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \newcommand{\leaf}[3]{{(cc #1 #2)\\[-1ex]\scriptsize #3}}
* Exercises for the Structure and Interpretation of Computer Languages
:PROPERTIES:
:header-args: :results silent :noweb yes
:header-args: :noweb yes
:END:
** Chapter 1: Building Abstractions with Procedures
*** 1.2 Procedures and the Processes They Generate
#+LaTeX_HEADER: \newcommand{\mya}[2]{ ( A\, #1\, #2) }
**** 1.2.1 Linear Recursion and Iteration

*Linear recursion* - the length of the chain of deferred operations, as well as
the amount of information needed to keep track of it, grows linearly with \(n\).

*iterative process* - state can be summarized by a fixed number of state
variables, together with a fixed rule that describes how they should be updated.

[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::44][*Exercise 1.10*]]

The following procedure computes a mathematical function called Ackermann’s
function.

#+begin_src scheme :session
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0)(* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+end_src

What are the values of the following expressions?

#+begin_src scheme
(A 1 10)
(A 2 4)
(A 3 3)
#+end_src

Consider the following procedures, where A is the procedure defined above:

#+begin_src scheme
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#+end_src

Give concise mathematical definitions for the functions computed by the
procedures f, g, and h for positive integer values of n. For example, (k n)
computes 5n 2.

Answer:

\[
\begin{align}
\mya{1}{x} &= \mya{0}{\mya{1}{(x - 1)}}   \\
           &= 2 \times \mya{1}{(x - 1)}   \\
\mya{1}{1} &= 2 \\
\mya{1}{x} &= 2^{x}
\end{align}
\]

Proof: \( \mya{1}{x} = 2 \times \mya{1}{(x - 1)} = 2 \times (2 ^{x - 1}) = 2
^{x}. \qedhere \)

\[
\begin{align}
\mya{2}{x} &= \mya{1}{\mya{2}{(x - 1)}} \\
           &= 2^{\mya{2}{(x - 1)}} \\
\mya{2}{1} &= 2 \\
\{\mya{2}{x}\} &= \{2, 2^2, 2^4, 2^8, \dots \} \\
           &= 2^{2^{x - 1}}
\end{align}
\]

Proof:
\[
\begin{align}
\mya{2}{x} &= 2^{\mya{2}{(x - 1)}} \\
           &= 2^{2^{2^{x - 2}}} \\
           &= 2^{2^{2^{x - 1} \times 2^{-1}}} \\
           &= 2^{(4^{x - 1})^{1/2}} \\
           &= 2^{2^{x - 1}}. \qedhere
\end{align}
\]
**** 1.2.2 Tree Recursion

*Example of tree recursion*: Counting Change
#+begin_src scheme
  (define (count-change amount)
    (cc amount 5))

  (define (cc amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins)))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))
#+end_src

*Exercise 1.11*

A function f is defined by the rule that \(f(n) = n\) if \(n<3\) and \(f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) \) if \(n \geq 3\). Write a procedure that computes \(f\) by means of a recursive process. Write a procedure that computes \(f\) by means of an iterative process.

=recursive=

a <- a + 2b + 3c
b <- a
c <- b

#+begin_src scheme
  (define (f n)
    (cond ((< n 3) n)
          (else (+ (f (- n 1))
                   (* 2 (f (- n 2)))
                   (* 3 (f (- n 3)))))))
#+end_src

=iterative=

#+begin_src scheme
  (define (fi n)
    (f-iter 2 1 0 n))

  (define (f-iter a b c count)
    (if (= count 0)
        c
        (f-iter (+ a (* 2 b) (* 3 c)) a b
                (- count 1))))
#+end_src

*Exercise 1.12*. The following pattern of numbers is called Pascal’s triangle. The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it. Write a procedure that computes elements of Pascal’s triangle by means of a recursive process.

#+begin_src scheme
  (define (pascal row column) ; the top is row 1,
    (if (or (= column 1)      ; the left side is col 1
            (= column row))
        1
        (+ (pascal (- row 1) column)
           (pascal (- row 1) (- column 1)))))
#+end_src

*Exercise 1.13*. Prove that \(Fib(n)\) is the closest integer to \(\phi^{n} / \sqrt{5}\), where \(\phi = (1 + \sqrt{5}) / 2\). Hint: Let \(\psi = (1 - \sqrt{5})/2\). Use induction and the definition of the Fibonacci numbers (see section 1.2.2) to prove that \(Fib(n) = ( \phi^{n} - \psi^{n})/ \sqrt{5}\).

_Proof_: \(Fib(1) = (\phi - \psi)/\sqrt{5} = \sqrt{5}/\sqrt{5} = 1\).

Assume \(Fib(n) = (\phi^{n}-\psi^{n})/\sqrt{5}\).
\[
\begin{align}
Fib(n + 1) &= Fib(n) + Fib(n-1) \\
           &= (\phi^{n}-\psi^{n}+\phi^{n-1}-\psi^{n-1})/\sqrt{5} \\
           &= ((\phi+1)\phi^{n-1} - (\psi+1) \psi^{n-1})/\sqrt{5} \\
           &= ((\frac{3+\sqrt{5}}{2})\phi^{n} - (\frac{3-\sqrt{5}}{2})\psi^{n})/\sqrt{5} \\
           &= (\phi^{2}\phi^{n-1} - \psi^{2}\psi^{n-1})/\sqrt{5} \\
           &= (\phi^{n+1} - \psi^{n+1})/\sqrt{5}
\end{align}
\]
**** 1.2.3 Orders of Growth
*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::48][Order of Growth]]*

\(R(n)\) has order of growth \(\Theta(f(n))\), written \(\R(n)=\Theta(f(n))\) (pronounced "theta of \(f(n)\)"), if there are positive constants \(k_{1}\) and \(k_{2}\) independent of \(n\) such that

\[ k_{1} f(n) \leq R(n) \leq k_{2} f(n) \]

for any sufficiently large value of \(n\).

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::49][Exercise 1.14]]*. Draw the tree illustrating the process generated by the src_scheme{count-change} procedure of section 1.2.2 in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?

\[
\begin{forest} for tree={align=center}
[\leaf{11}{5}{4}
 [\leaf{11}{4}{4}
  [\leaf{11}{3}{4}
   [\leaf{11}{2}{3}
    [\leaf{11}{1}{1}
     [\leaf{11}{0}{0}]
     [\leaf{10}{1}{1}
      [\leaf{10}{0}{0}]
       [\dots
        [\leaf{0}{1}{1}]]]]
    [\leaf{6}{2}{2}
     [\leaf{6}{1}{1}
      [\dots [\leaf{0}{1}{1}]]]
     [\leaf{1}{2}{1}
      [\leaf{1}{1}{1}]
      [\leaf{-4}{2}{0}]]]]
   [\leaf{1}{3}{1}
    [\dots [\leaf{0}{1}{1}]]
    [\leaf{-9}{3}{0}]]]
  [\leaf{-14}{4}{0}]]
 [\leaf{-39}{5}{0}]]
\end{forest}
\]

An upper bound on the order of growth is \( (n + 1) \times (k + 1)\), where \(n\) is the total amount and \(k\) is the kinds of change.

Proof: We assert that all the possible argument pairs to the function that are called are integers \((i, j)\) with \(i = {0,\dots,n}\), \(j = {0,\dots,k}\), and each is called at most once. The first call is with \((n, k)\), thereafter each subsequent call either decreases the first argument or the second argument, but not both. So any given pair can be reached from a certain pair and prior operation: decrease \(i\) or decrease \(j\). ...

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::49][Exercise 1.15]]*. The sine of an angle (specified in radians) can be computed by making use of the approximation \(sin x ~= x \) if \(x\) is sufficiently small, and the trigonometric identity
\[
\sin r = 3 \sin \frac{r}{3} - 4 \sin^{3} \frac{r}{3}
\]

to reduce the size of the argument of \(\sin\). (For purposes of this exercise an angle is considered "sufficiently small" if its magnitude is not greater than 0.1 radians.) These ideas are incorporated in the following procedures:

#+begin_src scheme :session sine
  (define (cube x) (* x x x))
  (define (p x) (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))
#+end_src

#+RESULTS:

a. How many times is the procedure p applied when (sine 12.15) is evaluated?

This function displays the iteration and value.

#+begin_src scheme :results output :session sine
  (define (p x) (- (* 3 x) (* 4 (cube x))))
  (define (cube x) (* x x x))
  (define (sine-count angle iter)
    (define (disp-iter val)
      (display iter)
      (display " ")
      (display val)
      (display "\n")
      val)
    (if (not (> (abs angle) 0.1))
        angle
        (disp-iter (p (sine-count (/ angle 3.0) (+ iter 1))))))

  (sine-count 12.15 1)
#+end_src

#+RESULTS:
: "5 0.1495\n4 0.4351345505\n3 0.9758465331678772\n2 -0.7895631144708228\n1 -0.39980345741334\n"

b. What is the order of growth in space and number of steps (as a function of \(a\)) used by the process generated by the sine procedure when (sine a) is evaluated?

The order of growth in steps equivalent to how quickly \(a\) goes to 0 in the argument of the call to src_scheme{sine}, which the smallest integer \(n\) where \(\frac{a}{3^{n}} \leq 0.1\), or \(n \geq \log_{3} 10a\), so \(\Theta(\log_{3} a)\). The order of growth in space is the same.
**** 1.2.4 Exponentiation
The basic recursive procedure for exponentiation:

#+begin_src scheme
  (define (expt b n)
    (if (= n 0)
        1
        (* b (expt b (- n 1)))))
#+end_src

is \(\Theta(n)\) in # of steps and the same in space.

The iterative procedure:

#+begin_src scheme :session expt
  (define (expti b n)
    (expt-iter b n 0 1))

  (define (expt-iter b n iter product)
    (if (= iter n)
        product
        (expt-iter b n (+ iter 1) (* product b))))
#+end_src

is \(\Theta(n)\) in # of steps, but only \(\Theta(1)\) in space, since there are no deferred operations.

But even better, if we take advantage of successive squaring (\(b^{8}=b^{2}^{2}^{2}\)), we can get \(Theta(\log n)\) in steps and space.

#+NAME: square
#+begin_src scheme
  (define (square a) (* a a))
#+end_src

#+NAME: fast_exp
#+begin_src scheme :session expt
  <<square>>
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-exp b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-exp b (/ n 2))))
          (else (* b (fast-exp b (- n 1))))))
#+end_src

The argument to, at worst every other call of fast-exp, is halved.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::51][Exercise 1.16]]*

Design a procedure that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does fast-expt. (Hint: Using the observation that \((b^{n/2})^{2} = (b^{2})^{n/2}\) , keep, along with the exponent \(n\) and the base \(b\), an additional state variable \(a\), and define the state transformation in such a way that the product \(a b^{n}\) is unchanged from state to state. At the beginning of the process \(a\) is taken to be 1, and the answer is given by the value of \(a\) at the end of the process. In general, the technique of defining an invariant quantity that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.)

#+begin_src scheme
  <<square>>

  (define (fast-expti b n)
    (fast-expt-iter n b 1))

  (define (fast-expt-iter n base a)
    (cond ((= n 0) 1)
          ((= n 1) (* base a))
          ((even? n) (fast-expt-iter (/ n 2) (square base) a))
          (else (fast-expt-iter (- n 1) base (* base a)))))
#+end_src

The pseudocode for this is:

#+begin_src
base = b
a = 1

if (n == 1) return 1

while (n > 1) {
  if (even? n) {
    base *= base
    n /= 2
  } else {
    a *= base
    n--
  }
}
base * a
#+end_src

*Exercise 1.17*. The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication procedure (in which it is assumed that our language can only add, not multiply) is analogous to the src_scheme{expt} procedure:

#+begin_src scheme
  (define (* a b)
    (if (= b 0)
        0
        (+ a (* a (- b 1)))))

#+end_src

This algorithm takes a number of steps that is linear in =b=. Now suppose we include, together with addition, operations =double=, which doubles an integer, and =halve=, which divides an (even) integer by 2. Using these, design a multiplication procedure analogous to =fast-expt= that uses a logarithmic number of steps.

#+begin_src scheme
  (define (double a) (+ a a))
  (define (halve a) (/ a 2))

  (define (fast-mult b n)
    (cond ((= n 0) 0)
          ((even? n) (double (fast-mult b (halve n))))
          (else (+ b (fast-mult b (- n 1))))))
#+end_src

*Exercise 1.18*. Using the results of exercises 1.16 and 1.17, devise a procedure that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.

#+begin_src scheme
  <<square>>

  (define (fast-multi b n)
    (fast-mult-iter n b 0))

  (define (fast-mult-iter n base a)
    (cond ((= n 0) 0)
          ((= n 1) (+ base a))
          ((even? n) (fast-mult-iter (halve n) (double base) a))
          (else (fast-mult-iter (- n 1) base (+ base a)))))
#+end_src

*Exercise 1.19*. There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps. Recall the transformation of the state variables a and b in the fib-iter process of section 1.2.2: \(a \leftarrow a + b\) and \(b \leftarrow a\). Call this transformation \(T\), and observe that applying \(T\) over and over again \(n\) times, starting with 1 and 0, produces the pair \(Fib(n + 1)\) and \(Fib(n)\). In other words, the Fibonacci numbers are produced by applying \(T^{n}\) , the nth power of the transformation \(T\), starting with the pair \((1,0)\). Now consider \(T\) to be the special case of \(p = 0\) and \(q = 1\) in a family of transformations \(T_{pq}\) , where \(T_{pq}\) transforms the pair \((a,b)\) according to \(a \leftarrow bq + aq + ap\) and \(b \leftarrow bp + aq\). Show that if we apply such a transformation \(T_{pq}\) twice, the effect is the same as using a single transformation \(T_{p’q'}\) of the same form, and compute p’ and q’ in terms of p and q. This gives us an explicit way to square these transformations, and thus we can compute T n using successive squaring, as in the fast-expt procedure. Put this all together to complete the following procedure, which runs in a logarithmic number of steps:

Answer: Start by rewriting \((T_{pq})^{2}\):

\[
\begin{align}
a & \leftarrow b_{1}q + a_{1}q + a_{1}p \\
  & = (bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p \\
  & = ap^{2} + 2(b + a)pq + (2a + b)q^{2} \\
  & = (b + a)q' + ap'
\end{align}
\]

\[
\begin{align}
b & \leftarrow b_{1}p + a_{1}q \\
  & = (bp + aq)p + (bq + aq + ap)q \\
  & = bp^{2} + 2apq + (a + b)q^{2} \\
  & = bp' + aq'
\end{align}
\]

These are solved with:

\[
\begin{align}
q' & = 2pq + q^2 \\
p' & = p^{2} + q^2
\end{align}
\]

#+begin_src scheme
  <<square>>

  (define (fib n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a b
                     (+ (square p) (square q))  ; compute p’
                     (+ (* 2 p q) (square q))   ; compute q’
                     (/ count 2)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p q (- count 1)))))
#+end_src
**** 1.2.5 Greatest Common Divisors
Review,*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::53][Euclid's method]]* for computing GCD:

#+NAME: gcd
#+begin_src scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
#+end_src

Interesting relationship to Fibonacci numbers.

*Lame's Theorem*: if Euclid's Algorithm takes \(k\) steps to compute the GCD of some pair, then the smaller number in the pair must be greater than or equal to the \(k\)th Fibonacci number.

Exercise 1.20. The process that a procedure generates is of course dependent on the rules used by the interpreter. As an example, consider the iterative gcd procedure given above. Suppose we were to interpret this procedure using normal-order evaluation, as discussed in section 1.1.5. (The normal-order-evaluation rule for if is described in exercise 1.5.) Using the substitution method (for normal order), illustrate the process generated in evaluating (gcd 206 40) and indicate the remainder operations that are actually performed. How many remainder operations are actually performed in the normal-order evaluation of (gcd 206 40)? In the applicative-order evaluation?

Normal order:
#+begin_src scheme
  (gcd 206 40)
  (if (= 40 0) 206 (gcd 40 (remainder 206 40)))
  (gcd 40 (remainder 206 40))
  (if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
  ;; remainder performed here => 6
  (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
  (if (= (remainder 40 (remainder 206 40)) 0) (remainder 206 40) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
  ;; 2 remainders performed here => 4
  (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
  (if ...)
  ;; 3 remainders performed here? => 2
  (gcd ...)
  (if ...)
  ;; 4 remainders performed here => 0
  (remainder ...)
  ;; 3 remainders performed to get answer
  2
#+end_src

\(1 + 2 + 3 + 4 + 3 = 13\) remainder calculations?

Applicative order:
#+begin_src scheme
  (gcd 206 40)
  (gcd 40 (remainder 206 40))
  (gcd 40 6)
  (gcd 6 (remainder 40 6))
  (gcd 6 4)
  (gcd 4 (remainder 6 4))
  (gcd 4 2)
  (gcd 2 (remainder 4 2))
  (gcd 2 0)
  2
#+end_src

4 remainder calculations
**** 1.2.6 Example: Testing for Primality
*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::54][Fermat's Little Theorem]]*: If n is a prime number and a is any positive integer less than n, then a raised to the nth power is congruent to a modulo n.

*congruent modulo n* means they both have the same remainder when divided by n.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::55][Exercise 1.21]]*. Use the smallest-divisor procedure to find the smallest divisor of each of the following numbers: 199, 1999, 19999.

#+NAME: fast_prime
#+begin_src scheme
  <<square>>

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  (define (fast-prime? n times)
    (cond ((= times 0) #t)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else #f)))
#+end_src

#+NAME: smallest_divisor
#+begin_src scheme
  <<square>>

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))
#+end_src

#+begin_src scheme :results value replace
  <<smallest_divisor>>
  (map smallest-divisor (list 199 1999 19999))
#+end_src

#+RESULTS:
: (199 1999 7)

*Exercise 1.22*. Most Lisp implementations include a primitive called runtime that returns an integer that specifies the amount of time the system has been running (measured, for example, in microseconds). The following timed-prime-test procedure, when called with an integer n, prints n and checks to see if n is prime. If n is prime, the procedure prints three asterisks followed by the amount of time used in performing the test.

#+NAME: timed_prime
#+begin_src scheme
  ;; need this in guile
  (define runtime get-internal-run-time)

  (define (timed-prime-test n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time) n)))

  (define (report-prime elapsed-time n)
    (display n)
    (display " *** ")
    (display elapsed-time)
    (newline))
#+end_src

Using this procedure, write a procedure search-for-primes that checks the primality of consecutive odd integers in a specified range. Use your procedure to find the three smallest primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test each prime. Since the testing algorithm has order of growth of \(\Theta(\sqrt{n})\), you should expect that testing for primes around 10,000 should take about \(\sqrt{10}\) times as long as testing for primes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the n prediction? Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?

#+NAME: test_primes
#+begin_src scheme
  (define (test-and-continue n m)
    (timed-prime-test n)
    (search-for-primes (+ n 2) m))

  (define (search-for-primes n m)
    (if (< n m)
        (test-and-continue n m)))

  (search-for-primes 1001 1020)
  (search-for-primes 10001 10038)
  (search-for-primes 100001 100044)
  (search-for-primes 1000001 1000038)
#+end_src

#+NAME: search_for_primes
#+begin_src scheme :results output replace
  <<smallest_divisor>>
  <<timed_prime>>

  (define (prime? n)
    (= n (smallest-divisor n)))

  <<test_primes>>
#+end_src

#+RESULTS: search_for_primes
: "1009 *** 5226\n1013 *** 5231\n1019 *** 5018\n10007 *** 15190\n10009 *** 15567\n10037 *** 15388\n100003 *** 47888\n100019 *** 46513\n100043 *** 47711\n1000003 *** 155896\n1000033 *** 146287\n1000037 *** 149025\n"

Yes, the difference in timing for testing each prime is roughly equal to \(\sqrt{10}\).

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::56][Exercise 1.23]]* The =smallest-divisor= procedure shown at the start of this section does lots of needless testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if it is divisible by any larger even numbers. This suggests that the values used for =test-divisor= should not be 2, 3, 4, 5, 6, ..., but rather 2, 3, 5, 7, 9, .... To implement this change, define a procedure =next= that returns 3 if its input is equal to 2 and otherwise returns its input plus 2. Modify the =smallest-divisor= procedure to use =(next test-divisor)= instead of =(+ test-divisor 1)=. With timed-prime-test incorporating this modified version of smallest-divisor, run the test for each of the 12 primes found in exercise 1.22. Since this modification halves the number of test steps, you should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?

#+NAME: prime
#+begin_src scheme
  <<smallest_divisor>>

  (define (smallest-divisor-fast n)
    (find-divisor-fast n 2))

  (define (next n)
    (if (= n 2) 3 (+ n 2)))

  (define (find-divisor-fast n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor-fast n (next test-divisor)))))

  (define (prime? n)
    (= n (smallest-divisor-fast n)))
#+end_src

#+begin_src scheme :results output raw replace
  <<test_primes>>
#+end_src

#+RESULTS:
"1009 *** 3692\n1013 *** 3662\n1019 *** 3565\n10007 *** 9692\n10009 *** 9595\n10037 *** 9700\n100003 *** 29441\n100019 *** 29209\n100043 *** 33358\n1000003 *** 90914\n1000033 *** 90855\n1000037 *** 94327\n"

No. The ratio in times is closer to 1.5. This is because =find-divisor= is \(\Theta(\sqrt{n})\) itself, due to checking only for divisors up to \(\sqrt{n}\).

*Exercise 1.24*. Modify the =timed-prime-test= procedure of exercise 1.22 to use =fast-prime?= (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat test has \(\Theta(\log n)\) growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000? Do your data bear this out? Can you explain any discrepancy you find?

You would expect the fractional difference in time to be \(\frac{\log{10^{6}}}{\log{10^{3}}} = 2\).

#+begin_src scheme :results output raw replace
  <<timed_prime>>
  <<fast_prime>>

  (define prime? (lambda (x) (fast-prime? x 10)))

  <<test_primes>>
#+end_src

#+RESULTS:
"1009 *** 43200\n1013 *** 44989\n1019 *** 46135\n10007 *** 56087\n10009 *** 58798\n10037 *** 58003\n100003 *** 65648\n100019 *** 67945\n100043 *** 67947\n1000003 *** 75438\n1000033 *** 75835\n1000037 *** 78192\n"

That is *roughly* the case, though it appears to be somewhat less than that. It could because algorithm is probabilistic, and the chance of a match for a prime as a function of n is affecting things. Also, the call to =random= may also have an effect.

*Exercise 1.25*. Alyssa P. Hacker complains that we went to a lot of extra work in writing =expmod=. After all, she says, since we already know how to compute exponentials, we could have simply written

#+NAME: expmod_simple
#+begin_src scheme
  (define (expmod-simple base exp m)
    (remainder (fast-exp base exp) m))
#+end_src

Is she correct? Would this procedure serve as well for our fast prime tester? Explain.

First off, why is it always a hypothetical female that seems to be mistaken in these examples?

This would have us creating on average exponents of size \((n/2)^{n}\), which will take up exponentially increasing amounts of space in addition to whatever additional time cost there is to =remainder=. In addition, =remainder= probably has some cost for large values.

#+begin_src scheme :results output raw replace
  <<fast_exp>>
  <<expmod_simple>>

  (define runtime get-internal-run-time)

  (define (timed-expmod-test n)
    (start-expmod-test n (runtime)))

  (define (start-expmod-test n start-time)
    (expmod-simple (+ 1 (random (- n 1))) n n)
    (report-expmod (- (runtime) start-time) n))

  (define (report-expmod elapsed-time n)
    (display n)
    (display " *** ")
    (display elapsed-time)
    (newline))

  (map timed-expmod-test (list 101 1001 10001 100001))
#+end_src

#+RESULTS:
"101 *** 34449\n1001 *** 24503\n10001 *** 299949\n100001 *** 7257138\n"

This test seems to confirm the time cost increases exponentially.

*Exercise 1.26*. Louis Reasoner is having great difficulty doing exercise 1.24. His fast-prime? test seems to run more slowly than his prime? test. Louis calls his friend Eva Lu Ator over to help. When they examine Louis’s code, they find that he has rewritten the expmod procedure to use an explicit multiplication, rather than calling square:

#+begin_src scheme
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (* (expmod base (/ exp 2) m)
                         (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))
#+end_src

"I don’t see what difference that could make," says Louis. "I do." says Eva. "By writing the procedure like that, you have transformed the \(\Theta(\log{n})\) process into a \(\Theta(n)\) process." Explain.

For each even exponent calculation, =expmod= will be called twice instead of once. Given that expmod is \(\Theta(\log{n})\), this implies \(2^{\log{n}} = n\) calculations.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::57][Exercise 1.27]]*. Demonstrate that the Carmichael numbers listed in footnote 47 really do fool the Fermat test. That is, write a procedure that takes an integer n and tests whether \(a^{n}\) is congruent to \(a\) modulo \(n\) for every \(a<n\), and try your procedure on the given Carmichael numbers.

#+begin_src scheme :results value replace
  <<fast_prime>>
  <<smallest_divisor>>
  (define (test-congruent a n)
    (= (expmod a n n) (remainder a n)))

  (define (fool-fermat? n)
    (fool-fermat-iter 2 n))

  (define (fool-fermat-iter a n)
    (or (>= a n)
        (and (test-congruent a n) (fool-fermat-iter (+ a 1) n))))

  (map fool-fermat? (list 561 1105 1729 2465 2821 6601))
#+end_src

#+RESULTS:
: (#t #t #t #t #t #t)

And just to confirm they aren't primes.

#+begin_src scheme :results value replace
  <<smallest_divisor>>
  (define (prime? n)
    (= n (smallest-divisor n)))
  (map prime? (list 561 1105 1729 2465 2821 6601))
#+end_src

#+RESULTS:
: (#f #f #f #f #f #f)

*Exercise 1.28* TODO
*** 1.3 Formulating Abstractions with Higher-Order Procedures
*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::60][Higher-order procedures]]* are procedures that manipulate procedures. Often the same programming pattern will be used with different procedures, it would be limiting not to be able to express these patterns in the language.

**** 1.3.1 Procedures as Arguments
We can write an abstract summing procedure, where =term= and =next= are procedures themselves that evaluate and increment the iteration respectively.

#+NAME: sum
#+begin_src scheme
  (define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))
#+end_src

#+NAME: integral
#+begin_src scheme
  (define (integral f a b dx)
    (define (add-dx x) (+ x dx))
    (* (sum f (+ a (/ dx 2.0)) add-dx b)
       dx))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::63][Exercise 1.29]]*. Simpson’s Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson’s Rule, the integral of a function f between a and b is approximated as where \(h = (b - a)/n\), for some even integer n, and \(y_{k} = f(a + kh)\). (Increasing n increases the accuracy of the approximation.) Define a procedure that takes as arguments f, a, b, and n and returns the value of the integral, computed using Simpson’s Rule. Use your procedure to integrate cube between 0 and 1 (with n = 100 and n = 1000), and compare the results to those of the integral procedure shown above.

#+NAME: simpsons
#+begin_src scheme
  ;; the coefficients of each term
  (define (simp-coef k n)
    (cond ((or (= k 0) (= k n)) 1)
          ((odd? k) 4)
          (else 2)))

  ;; this is a "generic" simpsons, taking arbitrary
  ;; coefficients and constant
  (define (simp-sum-generic f n a b coef const)
    (define (simpterm i)
      (* (coef i n) (f (+ a (* (/ i n) (- b a))))))
    (define (simpnext i) (+ i 1))
    (* const (sum simpterm 0 simpnext n)))

  (define (simpsons f n a b)
    (simp-sum-generic f n a b simp-coef (/ (- b a) (* n 3))))
#+end_src

#+NAME: simpsons-approx
#+begin_src scheme :results value replace
  <<sum>>
  <<integral>>
  <<simpsons>>

  (define (cube x) (* x x x))

  (define (approx-compare n)
    (list (simpsons cube n 0 1)
        (integral cube 0 1 (/ 1 n))))

  (map approx-compare (list 100 1000))
#+end_src

#+RESULTS: simpsons-approx
: ((1/4 0.24998750000000042) (1/4 0.249999875000001))

*Exercise 1.30*. The sum procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:

#+begin_src scheme sum
  ;; (define (sum term a next b)
  ;;   (define (iter a result)
  ;;     (if <??>
  ;;         <??>
  ;;         (iter <??> <??>)))
  ;;   (iter <??> <??>))

  (define (sumi term a next b)
    (define (iter i result)
      (if (> i b)
          result
          (iter (next i) (+ result (term i)))))
    (iter a 0))
#+end_src

*Exercise 1.31*.
a. The =sum= procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures. Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to \(\pi\) using the formula

\[
\frac{\pi}{4} = \frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \dots}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \dots}
\]

#+NAME: product
#+begin_src scheme
  (define (prodi term a next b)
    (define (iter i result)
      (if (> i b)
          result
          (iter (next i) (* result (term i)))))
    (iter a 1))

  (define (prodr term a next b)
    (if (> a b)
        1
        (* (term a)
           (prodr term (next a) next b))))

  (define (pi-approx n)
    (define (iter i) (+ i 1))
    (define (imod2 i) (+ i (remainder i 2)))
    (define (term i) (/ (imod2 (+ i 1)) (+ 1 (imod2 i))))
    (* 4 (prodi term 1 iter n)))
#+end_src

b. If your product procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.

*Exercise 1.32*. a. Show that sum and product (exercise 1.31) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function:

#+begin_src scheme
  (accumulate combiner null-value term a next b)
#+end_src

=accumulate= takes as arguments the same term and range specifications as =sum= and =product=, together with a =combiner= procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a =null-value= that specifies what base value to use when the terms run out. Write =accumulate= and show how =sum= and =product= can both be defined as simple calls to =accumulate=.

#+NAME: accumulate
#+begin_src scheme :results value replace
  (define (accumulatei combiner null-value term a next b)
    (define (iter i result)
      (if (= i (next b))
          result
          (iter (next i) (combiner result (term i)))))
    (iter a null-value))

  (define (accumulater combiner null-value term a next b)
    (if (= a (next b))
        null-value
        (combiner a (accumulater combiner null-value
                     term (next a) next b))))
#+end_src

#+begin_src scheme
  <<accumulate>>
  (define (suma term a next b)
    (accumulatei + 0 term a next b))

  (define (proda term a next b)
    (accumulatei * 1 term a next b))

  <<sum>>
  <<product>>

  (define (accum-compare f f-accum term a next b)
    (list (f term a next b) (f-accum term a next b)))

  (define (identity x) x)
  (define (inc x) (+ x 1))

  (list (accum-compare sum suma identity 10 inc 20)
        (accum-compare prodi proda identity 10 inc 20)
        (accumulater + 0 identity 10 inc 20)
        (accumulater * 1 identity 10 inc 20))
#+end_src

#+RESULTS: accumulate
: ((165 165) (6704425728000 6704425728000) 165 6704425728000)

b. If your accumulate procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.

(see =accumulater= above, and the final test)

*Exercise 1.33*. You can obtain an even more general version of accumulate (exercise 1.32) by introducing the notion of a filter on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting =filtered-accumulate= abstraction takes the same arguments as =accumulate=, together with an additional predicate of one argument that specifies the filter. Write =filtered-accumulate= as a procedure. Show how to express the following using filtered-accumulate:

#+NAME: filtered_accumulate
#+begin_src scheme
  (define (filtered-accumulate combiner filter null-value term a next b)
    (define (iter i result)
      (if (= i (next b))
          result
          (iter (next i)
                (combiner result (if (filter i) (term i) null-value)))))
    (iter a null-value))
#+end_src

a. the sum of the squares of the prime numbers in the interval a to b (assuming that you have a =prime?= predicate already written)

#+begin_src scheme
  <<filtered_accumulate>>
  <<smallest_divisor>>
  <<square>>

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (inc x) (+ x 1))

  (define (sum-sq-primes a b)
     (filtered-accumulate + prime? 0 square a inc b))
#+end_src

b. the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers \(i < n\) such that \(GCD(i,n) = 1\)).

#+begin_src scheme :results value replace
  <<filtered_accumulate>>
  <<gcd>>
  (define (rel-prime? a b) (= (gcd a b) 1))
  (define (identity x) x)
  (define (inc x) (+ x 1))
  (define (prod-rel-prime n)
     (define (rel-prime-n? x) (rel-prime? x n))
     (filtered-accumulate * rel-prime-n? 1 identity 1 inc n))

  (map prod-rel-prime (list 1 2 3 4 5 6 7))
#+end_src

#+RESULTS:
: (1 1 2 3 24 5 720)

**** 1.3.2 Constructing Procedures Using =Lambda=
[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::64][=lambda=]] can be read as "the procedure of an argument(s) x, ... that ..."

[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::66][=let=]] is a special form of =lambda=.

#+begin_src scheme
  (let ((<var-1 > <exp-1 >)
        (<var-2 > <exp-2 >)
        ...
        (<var-n > <exp-n >))
    <body>)

  ((lambda (<var-1 > ...<var-n >)
     <body>)
   <exp-1>
   ...
   <exp-n>)
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::67][Exercise 1.34]]*. Suppose we define the procedure

#+begin_src scheme
(define (f g)
  (g 2))
#+end_src

Then we have

#+begin_src scheme
<<square>>
(f square)
4
(f (lambda (z) (* z (+ z 1))))
6
#+end_src

What happens if we (perversely) ask the interpreter to evaluate the combination src_scheme{(f f)}? Explain.

We can think of g as a lambda.

#+begin_src scheme
  (f (lambda (h) (h 2)))
  ((lambda (h) (h 2)) 2)
  (2 2)
  ; error?, can't apply 2

  (f f)
  (f 2)
  (2 2)
#+end_src
**** 1.3.3 Procedures as General Methods
A *[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::69][fixed point]]* satisfies \(f(x) = x\). It's common to find fixed points by starting with a guess and repeatedly applying \(f\), so \(f(a), f(f(a)), f(f(f(a))), \dots\).

#+NAME: tolerance
#+begin_src scheme
(define tolerance 0.00001)
#+end_src

#+NAME: fixed_point
#+begin_src scheme
  <<tolerance>>
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))
#+end_src

Observation: finding a square root of \(x\) (the \(y\) such that \(y^{2}=x\)) is just finding a fixed point of \(f(y) = x/y\). If we used the standard method, we'd get \(y_{1}, x / y_{1}, x/(x/y_{1}) = y_{1}, \dots \), which just oscillates between \(x\) and our first and second guesses.

One way to deal with this is to make better guesses, and since the answer is always between the guess \(y\) and \(y/x\), use the average. So instead of the second guess being \(x / y_{1}\), it is \(\frac{y_{1} + x/y_{1}}{2}\).

This is a fixed point of \(f(y) = (1/2)(y + x/y)\), which is another way of writing \(y=f(y)=x/y\) (just add \(y\) to each side, \(2y=y + x/y\)).

This is called *average damping*.

*Exercise 1.35*. Show that the golden ratio (section 1.2.2) is a fixed point of the transformation \(x + 1/x\), and use this fact to compute by means of the fixed-point procedure.

The golden ratio satisfies: \(\phi^{2} = \phi + 1\), which can be rewritten \(\phi = 1 + \frac{1}{\phi}\).

#+NAME: golden_ratio
#+begin_src scheme :results replace
<<fixed_point>>
(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)
#+end_src

#+RESULTS: golden_ratio
: 1.6180327868852458

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::71][Exercise 1.36]]*. Modify fixed-point so that it prints the sequence of approximations it generates, using the newline and display primitives shown in exercise 1.22. Then find a solution to \(x^{x} = 1000\) by finding a fixed point of \(x \rightarrow \log(1000)/\log(x)\). (Use Scheme’s primitive log procedure, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start fixed-point with a guess of 1, as this would cause division by log(1) = 0.)

#+NAME: fixed_point_print
#+begin_src scheme
  <<tolerance>>
  (define (fixed-point-print f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (display guess)
      (newline)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))
#+end_src

(without damping)

#+NAME: x_to_x
#+begin_src scheme
  (define (x-to-x x) (/ (log 1000) (log x)))
#+end_src

#+begin_src scheme :results output replace
  <<fixed_point_print>>
  <<x_to_x>>
  (fixed-point-print x-to-x 2.0)
#+end_src

#+RESULTS:
: "2.0\n9.965784284662087\n3.004472209841214\n6.279195757507157\n3.759850702401539\n5.215843784925895\n4.182207192401397\n4.8277650983445906\n4.387593384662677\n4.671250085763899\n4.481403616895052\n4.6053657460929\n4.5230849678718865\n4.577114682047341\n4.541382480151454\n4.564903245230833\n4.549372679303342\n4.559606491913287\n4.552853875788271\n4.557305529748263\n4.554369064436181\n4.556305311532999\n4.555028263573554\n4.555870396702851\n4.555315001192079\n4.5556812635433275\n4.555439715736846\n4.555599009998291\n4.555493957531389\n4.555563237292884\n4.555517548417651\n4.555547679306398\n4.555527808516254\n4.555540912917957\n"

#+begin_src scheme :results output replace
  <<tolerance>>
  <<x_to_x>>
  (define (fixed-point-damped-print f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (damped-guess x) (/ (+ x (f x)) 2))
    (define (try guess)
      (display guess)
      (newline)
      (let ((next (damped-guess guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))
  (fixed-point-damped-print x-to-x 2.0)
#+end_src

#+RESULTS:
: "2.0\n5.9828921423310435\n4.922168721308343\n4.628224318195455\n4.568346513136242\n4.5577305909237005\n4.555909809045131\n4.555599411610624\n4.5555465521473675\n"

(8 steps vs ~28)

*Exercise 1.37*. a. An infinite continued fraction is an expression of the form

\[
f = \frac{N_{1}}{D_{1} + \frac{N_{2}}{D_{2} + \frac{N_{3}}{D_{3} + \hdots}}}
\]

As an example, one can show that the infinite continued fraction expansion with the \(N_{i}\) and the \(D_{i}\) all equal to 1 produces \(1/\phi\) , where \(\phi\) is the golden ratio (described in section 1.2.2). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such a truncation -- a so-called *k-term finite continued fraction* -- has the form

\[
\frac{N_{1}}{D_{1} + \frac{N_{2}}{\ddots + \frac{N_{K}}{D_{K}}}}
\]

Suppose that =n= and =d= are procedures of one argument (the term index =i=) that return the \(N_{i}\) and \(D_{i}\) of the terms of the continued fraction. Define a procedure =cont-frac= such that evaluating =(cont-frac n d k)= computes the value of the k-term finite continued fraction. Check your procedure by approximating \(1/\phi\) using

#+begin_src scheme
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
#+end_src

for successive values of k. How large must you make k in order to get an approximation that is accurate to 4 decimal places?

#+NAME: cont_frac
#+begin_src scheme
  (define (dec x) (- x 1))

  (define (cont-fraci n d k)
    (define (iter i result)
      (if (= i 0)
          result
          (iter (dec i) (/ (n i) (+ (d i) result)))))
    (iter k 0))
#+end_src

#+begin_src scheme :results replace
  (/ 1 (cont-fraci (lambda (i) 1.0) (lambda (i) 1.0) 13))

#+end_src

#+RESULTS:
: 1.6180257510729614

With trial and error it took \(k=13\).

b. If your cont-frac procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.

(recursive process)

#+begin_src scheme :results replace
  (define (cont-fracr n d k)
    (define (rec i)
       (if (> i k)
           0
           (/ (n i) (+ (d i) (rec (+ i 1))))))
    (rec 1))

  (/ 1 (cont-fracr (lambda (i) 1.0) (lambda (i) 1.0) 13))
#+end_src

#+RESULTS:
: 1.6180257510729614

*Exercise 1.38*. In 1737, the Swiss mathematician Leonhard Euler published a memoir De Fractionibus Continuis, which included a continued fraction expansion for \(e - 2\), where \(e\) is the base of the natural logarithms. In this fraction, the \(N_{i}\) are all 1, and the \(D_{i}\) are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, .... Write a program that uses your =cont-frac= procedure from exercise 1.37 to approximate \(e\), based on Euler’s expansion.

#+begin_src scheme :results replace
<<cont_frac>>

(define (euler-d i)
   (if (not (= (remainder i 3) 2))
       1.0
       (* 2.0 (/ (+ i 1) 3))))

(+ 2 (cont-fraci (lambda (i) 1.0) euler-d 13))
#+end_src

#+RESULTS:
: 2.718281828735696

*Exercise 1.39*. A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:

\[
\tan x = \frac{x}{1 - \frac{x^{2}}{3 - \frac{x^{2}}{5 - \ddots}}}
\]

where x is in radians. Define a procedure =(tan-cf x k)= that computes an approximation to the tangent function based on Lambert’s formula. =k= specifies the number of terms to compute, as in exercise 1.37.

#+begin_src scheme
<<cont_frac>>

(define (tan-cf x k)
   (/ (cont-fraci (lambda (i) (- (* x x)))
                  (lambda (i) (- (* i 2) 1)) k)
      (- x)))
#+end_src
**** 1.3.4 Procedures as Returned Values
*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::73][Newton's method]]* converges very rapidly to find zeros of a differentiable function \(x \mapsto g(x)\), by finding the fixed point of \(x \mapsto f(x)\):

\[
f(x) = x - \frac{g(x)}{Dg(x)}
\]

We can define a derivative function, which returns a function:

#+NAME: deriv
#+begin_src scheme
  <<infi>>
  (define (deriv g)
    (lambda (x)
      (/ (- (g (+ x dx)) (g x))
         dx)))
#+end_src

#+NAME: infi
#+begin_src scheme
  (define dx 0.00001)
#+end_src

And now define newton's method:

#+NAME: newtons
#+begin_src scheme
  <<fixed_point>>
  (define (newton-transform g)
    (lambda (x)
      (- x (/ (g x) ((deriv g) x)))))

  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))
#+end_src

We can use this to find square roots (\(\sqrt{x}\) is a fixed point of \(y \mapsto y^{2} - x\)):

#+begin_src scheme
  <<square>>
  (define (sqrt-newton x)
    (newtons-method (lambda (y) (- (square y) x)) 1.0))
#+end_src

An abstraction of this concept is:

#+NAME: fixed_point_transform
#+begin_src scheme
  <<fixed_point>>
  (define (fixed-point-of-transform g transform guess)
    (fixed-point (transform g) guess))
#+end_src

Which makes the average-dampening sqrt:

#+NAME: average_damp
#+begin_src scheme
  (define (average-damp f)
    (lambda (x) (/ (+ (f x) x) 2)))
#+end_src

#+begin_src scheme
  <<fixed_point_transform>>
  (define (sqrt-avg x)
    (fixed-point-of-transform (lambda (y) (/x y))
                              average-damp
                              1.0))
  (define (sqrt-newt x)
    (fixed-point-of-transform (lambda (y) (- (square y) x))
                              newton-transform
                              1.0))
#+end_src

In scheme/lisp procedures are *first-class* elements.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::75][Exercise 1.40]]* Define a procedure cubic that can be used together with the newtons-method procedure in expressions of the form

#+begin_src scheme
  (newtons-method (cubic a b c) 1)
#+end_src

to approximate zeros of the cubic \(x^{3} + ax^{2} + bx + c\).

#+NAME: cube
#+begin_src scheme
  (define (cube x) (* x x x))
#+end_src

#+begin_src scheme
  <<cube>>
  (define (cubic a b c)
    (lambda (x) (+ (cube x) (* a (square x)) (* b x) c)))
#+end_src

*Exercise 1.41*. Define a procedure double that takes a procedure of one argument as argument and returns a procedure that applies the original procedure twice. For example, if inc is a procedure that adds 1 to its argument, then (double inc) should be a procedure that adds 2. What value is returned by

#+begin_src scheme :results replace
  <<double>>
  <<inc>>
  (((double (double double)) inc) 5)
#+end_src

#+RESULTS:
: 21

#+NAME: double
#+begin_src scheme
  (define (double f)
    (lambda (x) (f (f x))))
#+end_src

#+NAME: inc
#+begin_src scheme
  (define (inc x) (+ x 1))
#+end_src

*Exercise 1.42*. Let f and g be two one-argument functions. The composition f after g is defined to be the function \(x \mapsto f(g(x))\). Define a procedure compose that implements composition. For example, if inc is a procedure that adds 1 to its argument,

#+begin_src scheme :results replace
  <<compose>>
  <<square>>
  <<inc>>
  ((compose square inc) 6)
#+end_src

#+RESULTS:
: 49

#+NAME: compose
#+begin_src scheme
  (define (compose f g)
    (lambda (x) (f (g x))))
#+end_src

*Exercise 1.43*. If \(f\) is a numerical function and \(n\) is a positive integer, then we can form the \(n\)th repeated application of \(f\), which is defined to be the function whose value at \(x\) is \(f(f(\dots(f(x)) \dots ))\). For example, if \(f\) is the function \(x \mapsto x + 1\), then the \(n\)th repeated application of \(f\) is the function \(x \mapsto x + n\). If \(f\) is the operation of squaring a number, then the \(n\)th repeated application of \(f\) is the function that raises its argument to the \(2^{n}\) th power. Write a procedure that takes as inputs a procedure that computes \(f\) and a positive integer \(n\) and returns the procedure that computes the \(n\)th repeated application of \(f\). Your procedure should be able to be used as follows:

#+begin_src scheme :results replace
  <<repeated>>
  <<square>>
  ((repeated square 2) 5)
#+end_src

#+RESULTS:
: 625

#+NAME: repeated
#+begin_src scheme
  <<compose>>
  (define (repeated f n)
    (if (= n 1)
        f
        (compose f (repeated f (- n 1)))))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::76][Exercise 1.44]]*. The idea of smoothing a function is an important concept in signal processing. If \(f\) is a function and \(dx\) is some small number, then the smoothed version of f is the function whose value at a point \(x\) is the average of \(f(x - dx)\), \(f(x)\), and \(f(x + dx)\). Write a procedure smooth that takes as input a procedure that computes \(f\) and returns a procedure that computes the smoothed \(f\). It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the \(n\)-fold smoothed function. Show how to generate the \(n\)-fold smoothed function of any given function using smooth and repeated from exercise 1.43.

#+NAME: smooth
#+begin_src scheme
  <<infi>>
  <<repeated>>
  (define (smooth f)
    (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))
  (define (n-smooth f n)
    ((repeated smooth n) f))
#+end_src

#+begin_src scheme :results replace
  <<smooth>>
  <<square>>
  (define small-num 0.0000001)
  (define (inv-sin x) (/ 1 (sin x)))
  (list ((smooth inv-sin) small-num)
        ((n-smooth inv-sin 2) small-num))
#+end_src

#+RESULTS:
: (3332666.5999933495 3332833.2874955214)

*Exercise 1.45*. We saw in section 1.3.3 that attempting to compute square roots by naively finding a fixed point of \(y \mapsto x/y\) does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped \(y \mapsto x/y^{2} \). Unfortunately, the process does not work for fourth roots -- a single average damp is not enough to make a fixed-point search for \(y \mapsto x/y^{3}\) converge. On the other hand, if we average damp twice (i.e., use the average damp of the average damp of \(y \mapsto x/y^{3}\) ) the fixed-point search does converge. Do some experiments to determine how many average damps are required to compute \(n\)th roots as a fixed-point search based upon repeated average damping of \(y \mapsto x/y^{n-1}\) . Use this to implement a simple procedure for computing \(n\)th roots using =fixed-point=, =average-damp=, and the repeated procedure of exercise 1.43. Assume that any arithmetic operations you need are available as primitives.

#+NAME: nth_root
#+begin_src scheme
  <<average_damp>>
  <<fixed_point_transform>>
  <<repeated>>

  (define (fourth-root x)
    (fixed-point-of-transform (lambda (y) (/ x (expt y 3)))
                              (repeated average-damp 2)
                              1.0))

  (define (nth-root-test x n reps)
    (fixed-point-of-transform (lambda (y) (/ x (expt y (- n 1))))
                              (repeated average-damp reps)
                              1.0))
  ;; these seem to never converge (i.e. loop endlessly in REPL),
  ;; but with reps+1 they succeed, so it seems reps = floor (log_2 n)
  ;; (nth-root-test 3 4 1)
  ;; (nth-root-test 3 8 2)
  ;; (nth-root-test 3 16 3)

  (define (nth-root x n)
    (fixed-point-of-transform (lambda (y) (/ x (expt y (- n 1))))
                              (repeated average-damp
                                 (centered-quotient (log n) (log 2)))
                              1.0))
#+end_src

#+begin_src scheme :results replace
  <<nth_root>>
  (nth-root (expt 2 64) 64)
#+end_src

#+RESULTS:
: 2.0000000000000853

*Exercise 1.46*. Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as iterative improvement. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a procedure =iterative-improve= that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess. =iterative-improve= should return as its value a procedure that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the sqrt procedure of section 1.1.7 and the fixed-point procedure of section 1.3.3 in terms of iterative-improve.

#+NAME: iimprove
#+begin_src scheme
(define (iterative-improve f-good-enough? f-improve)
  (lambda (x)
    (define (iter guess)
      (if (f-good-enough? guess)
          guess
          (iter (f-improve guess))))
    (iter x)))
#+end_src

#+begin_src scheme :results replace
<<iimprove>>
<<square>>
(define (sqrt-ii x)
  ((iterative-improve
     (lambda (guess) (< (abs (- (square guess) x)) 0.001))
     (lambda (guess) (/ (+ guess (/ x guess)) 2.0)))
    x))
(list (sqrt-ii 43)
      (sqrt 43))
#+end_src

#+RESULTS:
: (6.557438561779193 6.557438524302)

#+begin_src scheme :results replace
<<iimprove>>
<<fixed_point>>
(define tolerance 0.00001)
(define (fixed-point-ii f first-guess)
  ((iterative-improve
     (lambda (guess) (< (abs (- guess (f guess))) tolerance))
     f)
    first-guess))

(list (fixed-point-ii cos 1.0)
      (fixed-point cos 1.0))
#+end_src

#+RESULTS:
: (0.7390893414033927 0.7390822985224024)
** Chapter 2: Building Abstractions with Data
*** 2.1 Introduction to Data Abstraction
**** 2.1.1 Example: Arithmetic Operations for Rational Numbers
We want to do arithmetic with rational numbers, and have the usual operations available. We can use =[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::82][cons]]=, =car= and =cdr= for this:

#+NAME: rat
#+begin_src scheme
  <<gcd>>
  (define (numer x) (car d))
  (define (denom x) (cdr x))
  (define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (equal-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))

  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::84][Exercise 2.1]]*. Define a better version of =make-rat= that handles both positive and negative arguments. =make-rat= should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.

#+begin_src scheme
  ;; <<rat>>
  (define (make-rat-imp n d)
    (let ((g (gcd n d))
          (neg (or (and (> n 0) (< d 0))
                   (and (< n 0) (> d 0)))))
      (cons ((if neg - +) (abs (/ n g))) (abs (/ d g)))))
#+end_src
**** 2.1.2 Abstraction Barriers
*Abstraction barriers* isolate different levels of data abstraction. E.g. we could implement =[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::85][make-rat]]=, =numer=, and =denom= differently by computing gcd when they are accessed (instead of when created), if that were a more frequent use case.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::86][Exercise 2.2]]*. Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor =make-segment= and selectors =start-segment= and =end-segment= that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordinate. Accordingly, specify a constructor =make-point= and selectors =x-point= and =y-point= that define this representation. Finally, using your selectors and constructors, define a procedure =midpoint-segment= that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you’ll need a way to print points:

#+NAME: average
#+begin_src scheme
  (define (average x y) (/ (+ x y) 2))
#+end_src

#+NAME: print_point
#+begin_src scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
#+end_src

#+NAME: segment
#+begin_src scheme
  <<print_point>>
  (define (make-point x y) (cons x y))
  (define (x-point p) (car p))
  (define (y-point p) (cdr p))

  (define (make-segment sp ep) (cons sp ep))
  (define (start-segment seg) (car seg))
  (define (end-segment seg) (cdr seg))

  <<average>>
  (define (midpoint-segment seg)
    (make-point (average (x-point (start-segment seg))
                         (x-point (end-segment seg)))
                (average (y-point (start-segment seg))
                         (y-point (end-segment seg)))))
#+end_src

#+begin_src scheme :results output replace
  <<segment>>
  (define my-seg (make-segment (make-point 0 0) (make-point 3 2)))
  (print-point (midpoint-segment my-seg))
#+end_src

#+RESULTS:
: "\n(3/2,1)"

*Exercise 2.3*. Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

#+NAME: seglength
#+begin_src scheme
  <<square>>
  (define (length-segment seg)
    (sqrt (+ (square (- (x-point (start-segment seg))
                        (x-point (end-segment seg))))
             (square (- (y-point (start-segment seg))
                        (y-point (end-segment seg)))))))
#+end_src

#+NAME: rectangle1
#+begin_src scheme
  <<segment>>
  <<seglength>>
  ;; a rectangle is defined by 3 points: origin, p1, p2
  (define (make-rect origin p1 p2)
    (cons origin (cons p1 p2)))

  (define (origin-rect r) (car r))
  (define (p1-rect r) (car (cdr r)))
  (define (p2-rect r) (cdr (cdr r)))

  (define (length r)
    (length-segment (make-segment (origin-rect r)
                                  (p1-rect r))))
  (define (width r)
    (length-segment (make-segment (origin-rect r)
                                  (p2-rect r))))
#+end_src

#+NAME: rectangle2
#+begin_src scheme
  <<segment>>
  <<seglength>>
  ;; a rectangle is defined by 2 perpendicular segments: seg1, seg2
  (define (make-rect seg1 seg2)
    (cons seg1 seg2))

  (define (seg1-rect r) (car r))
  (define (seg2-rect r) (cdr r))

  (define (length r) (length-segment (seg1-rect r)))
  (define (width r) (length-segment (seg2-rect r)))
#+end_src

#+NAME: rect_metrics
#+begin_src scheme
(define (perimeter r) (+ (* (length r) 2) (* (width r) 2)))
(define (area r) (* (length r) (width r)))
#+end_src

#+NAME: rect_points
#+begin_src scheme
  (define orig (make-point 0 0))
  (define p1 (make-point 3 0))
  (define p2 (make-point 0 4))
#+end_src

Using the first representation and perimeter and area functions.

#+begin_src scheme :results replace
  <<rectangle1>>
  <<rect_metrics>>
  <<rect_points>>
  (define rect1 (make-rect orig p1 p2))
  (list (perimeter rect1) (area rect1))
#+end_src

#+RESULTS:
: (14 12)

Using the second representation...

#+begin_src scheme :results replace
  <<rectangle2>>
  <<rect_metrics>>
  <<rect_points>>
  (define rect2 (make-rect (make-segment orig p1)
                           (make-segment orig p2)))
  (list (perimeter rect2) (area rect2))
#+end_src

#+RESULTS:
: (14 12)
**** 2.1.3 What Is Meant by Data?
[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::86][In general]], we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill to be valid.

For example, we could implement =cons=, =car= and =cdr= as procedures, in the style of *message passing*.

#+NAME: cons_mp
#+begin_src scheme
  (define (cons-mp x y)
    (lambda (m)
      (cond ((= m 0) x)
            ((= m 1) y)
            (else "Error: Argument not 0 or 1"))))
  (define (car-mp z) (z 0))
  (define (cdr-mp z) (z 1))
#+end_src

#+begin_src scheme :results replace
  <<cons_mp>>
  (define a (cons-mp 2 3))
  (list (car-mp a)
        (cdr-mp a))
#+end_src

#+RESULTS:
: (2 3)

*Exercise 2.4*. Here is an alternative procedural representation of pairs. For this representation, verify that =(car (cons x y))= yields =x= for any objects =x= and =y=.

#+NAME: pairs_alt
#+begin_src scheme
  (define (cons-alt x y)
    (lambda (m) (m x y)))
  (define (car-alt z)
    (z (lambda (p q) p)))
#+end_src

What is the corresponding definition of =cdr=? (Hint: To verify that this works, make use of the substitution model of [[pdfview:/home/jowalski/usbcrypt/sicp.pdf::25][section 1.1.5]].)

#+begin_src scheme :results replace
  <<pairs_alt>>
  (car-alt (cons-alt 3 4))
#+end_src

#+RESULTS:
: 3

#+begin_src scheme :results replace
  <<pairs_alt>>
  (define (cdr-alt z)
    (z (lambda (p q) q)))
  (cdr-alt (cons-alt 3 4))
#+end_src

#+RESULTS:
: 4

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::88][Exercise 2.5]]*. Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair \(a\) and \(b\) as the integer that is the product \(2^{a} 3^{b}\) . Give the corresponding definitions of the procedures cons, car, and cdr.

#+NAME: pairs_int
#+begin_src scheme
  (define (cons-expt a b) (* (expt 2 a) (expt 3 b)))

  (define (car-expt z)
    (define (car-iter n i)
      (if (> (modulo z i) 0)
          (- n 1)
          (car-iter (+ n 1) (* i 2))))
    (car-iter 1 2))

  (define (cdr-expt z)
    (define (cdr-iter n i)
      (if (> (modulo z i) 0)
          (- n 1)
          (cdr-iter (+ n 1) (* i 3))))
    (cdr-iter 1 3))
#+end_src

#+begin_src scheme :results replace
  <<pairs_int>>
  (define p-expt (cons-expt 5 3))
  (list (car-expt p-expt)
        (cdr-expt p-expt))
#+end_src

#+RESULTS:
: (5 3)

*Exercise 2.6*. In case representing pairs as procedures wasn’t mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

#+NAME: church_numerals
#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the calculus. Define one and two directly (not in terms of =zero= and =add-1=). (Hint: Use substitution to evaluate =(add-1 zero)=). Give a direct definition of the addition procedure =+= (not in terms of repeated application of =add-1=).

Using substitution...

#+begin_src scheme
  ;; using substitution
  (add-1 zero)
  (lambda (f) (lambda (x) (f ((zero f) x))))
  (lambda (f) (lambda (x) (f x)))         ; one

  (add-1 one)
  (lambda (f) (lambda (x) (f ((one f) x))))
  (lambda (f) (lambda (x) (f (f x))))     ; two
#+end_src

Numerals are functions that apply a function \(n\) number of times, where \(n\) is the numeral.

#+NAME: church_defs
#+begin_src scheme
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  (define (add-church a b)
    (lambda (f) (lambda (x) ((b f) ((a f) x)))))
#+end_src

We can test this.

#+begin_src scheme :results replace
  <<church_numerals>>
  <<church_defs>>
  <<inc>>
  <<square>>

  (list (((add-church two one) inc) 0)    ; should be 3
        (((add-church one two) -) 123)    ; should apply (-) 3 times
        (((add-church one one) square) 3)  ; should square 3 twice
        )
#+end_src

#+RESULTS:
: (3 -123 81)
**** 2.1.4 Extended Exercise: Interval Arithmetic
We create an interval object with these methods.

#+NAME: interval_add
#+begin_src scheme
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))
#+end_src

#+NAME: interval_div
#+begin_src scheme
  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))
#+end_src

[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::89][Exercise 2.7]]. Alyssa’s program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:

#+NAME: interval_construct
#+begin_src scheme
(define (make-interval a b) (cons a b))
#+end_src

Define selectors upper-bound and lower-bound to complete the implementation.

#+NAME: interval_bound
#+begin_src scheme
(define (upper-bound x) (cdr x))
(define (lower-bound x) (car x))
#+end_src


*Exercise 2.8*. Using reasoning analogous to Alyssa’s, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called sub-interval.

#+NAME: interval_sub
#+begin_src scheme
  (define (sub-interval x y)
    (let ((p1 (- (lower-bound x) (lower-bound y)))
          (p2 (- (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2) (max p1 p2))))
#+end_src

*Exercise 2.9*. The width of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.

Let \(w_{x}\) be the width of interval \(x\), \((x_{l}, x_{u})\) and \((y_{l}, y_{u})\) be two intervals. By the definitions of addition and width, we have:

\[
\begin{align}
w_{x+y} & = \frac{(x + y)_{u} - (x + y)_{l}}{2} \\
        & = (1/2)(x_{u} - x_{l} + y_{u} - y_{l}) \\
        & = w_{x} + w_{y}
\end{align}
\]

\[
\begin{align}
w_{x-y} & = \frac{(x-y)_{u} - (x-y)_{l}}{2} \\
        & = (1/2)(\max(x_{u}-y_{u},x_{l}-y_{l})-\min(x_{u}-y_{u},x_{l}-y_{l})) \\
        & = (1/2)(|(x_{u} - y_{u}) - (x_{l} - y_{l})|) \\
        & = (1/2)(|(x_{u} - x_{l}) - (y_{u} - y_{l})|) \\
        & = |w_{x} - w_{y}|
\end{align}
\]

#+NAME: interval_width
#+begin_src scheme
(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))
#+end_src

Here are counterexamples for multiplication and division.

#+NAME: interval
#+begin_src scheme :results replace
<<interval_add>>
<<interval_construct>>
<<interval_bound>>
<<interval_div>>
<<interval_sub>>
<<interval_width>>

(define i1 (make-interval 1 1.5))
(define i2 (make-interval 2 4))
(list (list (width-interval (mul-interval i1 i2))
            (* (width-interval i1) (width-interval i2)))
      (list (width-interval (div-interval i2 i1))
            (/ (width-interval i2) (width-interval i1))))
#+end_src

#+RESULTS: interval
: ((2.0 0.25) (1.3333333333333335 4.0))

*Exercise 2.10*. Ben Bitdiddle, an expert systems programmer, looks over Alyssa’s shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa’s code to check for this condition and to signal an error if it occurs.

#+NAME: interval_div0
#+begin_src scheme
  (define (div-interval x y)
    (if (and (> (upper-bound y) 0)
             (< (lower-bound y) 0))
        (display "Error: dividing by an interval that spans zero")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))
        )
    )
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::90][Exercise 2.11]]*. In passing, Ben also cryptically comments: "By testing the signs of the endpoints of the intervals, it is possible to break =mul-interval= into nine cases, only one of which requires more than two multiplications." Rewrite this procedure using Ben’s suggestion.

#+NAME: mul_interval9
#+begin_src scheme
  (define (mul-interval9 x y)
    (define (ubpos a) (>= (upper-bound a) 0))
    (define (lbpos a) (>= (lower-bound a) 0))
    (define (ubneg a) (< (upper-bound a) 0))
    (define (lbneg a) (< (lower-bound a) 0))
    (define lxly (* (lower-bound x) (lower-bound y)))
    (define lxuy (* (lower-bound x) (upper-bound y)))
    (define uxly (* (upper-bound x) (lower-bound y)))
    (define uxuy (* (upper-bound x) (upper-bound y)))
    ;; 1 both all pos,
    (cond ((and (lbpos x) (lbpos y))
           (make-interval lxly uxuy))
          ;; 2 both all neg
          ((and (ubneg x) (ubneg y))
           (make-interval uxuy lxly))
          ;; 3 x pos y straddle
          ((and (lbpos x) (ubpos y))
           (make-interval uxly uxuy))
          ;; 4 x straddle, y pos
          ((and (ubpos x) (lbpos y))
           (make-interval lxuy uxuy))
          ;; 5 x neg, y straddle
          ((and (ubneg x) (lbneg y) (ubpos y))
           (make-interval lxuy lxly))
          ;; 6 x straddle, y neg
          ((and (lbneg x) (ubpos x) (ubneg y))
           (make-interval uxly lxly))
          ;; 7 xpos yneg
          ((and (lbpos x) (ubneg y))
           (make-interval uxly lxuy))
          ;; 8 xneg ypos
          ((and (ubneg x) (lbpos y))
           (make-interval lxuy uxly))
          ;; 9 x straddle, y straddle  <= >2 multiplications
          (else
           (make-interval (min lxuy uxly)
                          (max uxuy lxly)))))
#+end_src

#+begin_src scheme :results replace
  <<interval>>
  <<mul_interval9>>
  (define i-neg (make-interval -3 -1))
  (define i-straddle (make-interval -4 5))
  (define i-pos (make-interval 0.5 0.75))

  (define (compare-mults i1 i2)
    (list (mul-interval i1 i2)
          (mul-interval9 i1 i2)))

  (list (compare-mults i-neg i-neg)
        (compare-mults i-neg i-straddle)
        (compare-mults i-neg i-pos)
        (compare-mults i-straddle i-neg)
        (compare-mults i-straddle i-straddle)
        (compare-mults i-straddle i-pos)
        (compare-mults i-pos i-neg)
        (compare-mults i-pos i-straddle)
        (compare-mults i-pos i-pos))
#+end_src

#+RESULTS:
: (((1 . 9) (1 . 9)) ((-15 . 12) (-15 . 12)) ((-2.25 . -0.5) (-2.25 . -0.5)) ((-15 . 12) (-15 . 12)) ((-20 . 25) (-20 . 25)) ((-3.0 . 3.75) (-3.0 . 3.75)) ((-2.25 . -0.5) (-2.25 . -0.5)) ((-3.0 . 3.75) (-3.0 . 3.75)) ((0.25 . 0.5625) (0.25 . 0.5625)))

#+NAME: center_width
#+begin_src scheme
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
#+end_src

*Exercise 2.12*. Define a constructor =make-center-percent= that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector percent that produces the percentage tolerance for a given interval. The center selector is the same as the one shown above.

#+NAME: center_percent
#+begin_src scheme
<<center_width>>
<<interval>>
(define (make-center-percent c t)
  (make-center-width c (/ (* c t) 100)))
(define (percent i)
  (* (/ (width i) (center i)) 100))
#+end_src

#+begin_src scheme :results replace
  <<center_percent>>
  (define i1 (make-center-percent 3 5))
  (list (center i1)
        (width i1)
        (percent i1))
#+end_src

#+RESULTS:
: (3 3/20 5)

*Exercise 2.13*. Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.

The *tolerance* is given by \(t_{x} = \frac{w_{x}}{c_{x}} = \frac{x_{u} - x_{l}}{2c_{x}}\).

So we start with tolerance of the product of intervals \(x\) and \(y\) and get:

\[
\begin{align}
t_{x \times y} &= \frac{(x \times y)_{u} - (x \times y)_{l}}{2c_{x \times y}} \\
               &= \frac{x_{u}y_{u} - x_{l}y_{l}}{(x \times y)_{u} + (x \times y)_{l}} \\
               &= \frac{x_{u}y_{u} - x_{l}y_{l}}{x_{u}y_{u} + x_{l}y_{l}} \\
               &= \frac{(x_{u} - x_{l})(y_{u} + y_{l}) + (x_{u} + x_{l})(y_{u} - y_{l})}{x_{u}y_{u} + x_{l}y_{l}} \\
               &\approx \frac{(x_{u} - x_{l})(y_{u} + y_{l}) + (x_{u} + x_{l})(y_{u} - y_{l})}{2c_{x}c_{y}} \\
               &= \frac{x_{u} - x_{l}}{c_{x}} + \frac{y_{u} + y_{l}}{c_{y}} \\
               &= 2t_{x} + 2t_{y}
\end{align}
\]

Where the approximation is possible because the denominator is much larger than the numerator, from the assumption of small tolerances.

*Definitions for Exercises 2.14-2.16*

Lem complains that Alyssa’s program gives different answers for the two ways of computing. This is a serious complaint.

#+NAME: parallel
#+begin_src scheme
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))
  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
                    (add-interval (div-interval one r1)
                                  (div-interval one r2)))))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::91][Exercise 2.14]]*. Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals A and B, and use them in computing the expressions A/A and A/B. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).

#+begin_src scheme :results replace
  <<center_percent>>
  <<parallel>>
  (define ra (make-center-percent 3 3))
  (define rb (make-center-percent 20 2))

  (list (list (percent (par1 ra rb)) (percent (par2 ra rb)))
        (list (percent (par1 ra ra)) (percent (par2 ra ra))))
#+end_src

#+RESULTS:
: ((7.119856933888341 2.8696219545614605) (8.978458162960003 2.9999999999999876))

*Exercise 2.15*. Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa’s system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, =par2= is a "better" program for parallel resistances than =par1=. Is she right? Why?

I'm not so sure. It might make it less likely, because there will potentially be fewer multiplications/divisions. See below for what I think the real reason is.

*Exercise 2.16*. Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)

We know from 2.9 that in our implementation multiplication and division of intervals do not necessarily yield intervals whose widths are a function of the initial widths. So the multiplication and division of intervals do not have the same properties as that for numbers. ??
*** 2.2 Hierarchical Data and the Closure Property
An operation for combining data objects satisfies the *closure property* if the results of applying the operation can in turn also be combined with the same operation. E.g., the result of a =cons= can also be =cons=ed.

This permits us to create *hierarchical* structures, structures made up of parts, which are made up of parts themselves, and so on.
**** 2.2.1 Representing Sequences


A  *[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::94][sequence]]* is an ordered collection of data objects.

A sequence of pairs formed by nested =cons= es is a *list*.

#+begin_src scheme
(list <a_1> <a_2> ... <a_n>)
#+end_src

is the same as

#+begin_src scheme
(cons <a_1> (cons <a_2> (cons ... (cons <a_n> nil))))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::96][Exercise 2.17]]*. Define a procedure =last-pair= that returns the list that contains only the last element of a given (nonempty) list:

#+begin_src scheme :results replace
<<last_pair>>
(last-pair (list 23 72 149 34))
#+end_src

#+RESULTS:
: 34

#+NAME: last_pair
#+begin_src scheme
  (define (last-pair l)
    (if (null? (cdr l))
        (car l)
        (last-pair (cdr l))))
#+end_src

*Exercise 2.18*. Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:

#+begin_src scheme :results replace
<<reverse>>
(reverse (list 1 4 9 16 25))
#+end_src

#+RESULTS:
: (25 16 9 4 1)

#+NAME: reverse
#+begin_src scheme
(define (reverse l)
  (define (iter l r)
    (if (null? l)
        r
        (iter (cdr l) (cons (car l) r))))
  (iter l #nil))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::97][Exercise 2.19]]*. Consider the change-counting program of section 1.2.2. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure =first-denomination= and partly into the procedure =count-change= (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.

We want to rewrite the procedure =cc= so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:

#+NAME: currency
#+begin_src scheme
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+end_src

We could then call =cc= as follows:

#+begin_src scheme
  (cc 100 us-coins)
  292
#+end_src

To do this will require changing the program =cc= somewhat. It will still have the same form, but it will access its second argument differently, as follows:

#+NAME: cc_new
#+begin_src scheme
  (define (cc-new amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc-new amount
                      (except-first-denomination coin-values))
              (cc-new (- amount
                         (first-denomination coin-values))
                      coin-values)))))
#+end_src

Define the procedures =first-denomination=, =except-first-denomination=, and =no-more?= in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by =cc=? Why or why not?

#+NAME: cc_new_defs
#+begin_src scheme
  (define first-denomination car)
  (define except-first-denomination cdr)
  (define no-more? null?)
#+end_src

#+begin_src scheme :results replace
  <<cc_new>>
  <<cc_new_defs>>
  <<reverse>>
  <<currency>>

  (list (cc-new 100 us-coins)
        (cc-new 100 (reverse us-coins)))
#+end_src

#+RESULTS:
: (292 292)

Exercise 2.20. The procedures =+=, =*=, and =list= take arbitrary numbers of arguments. One way to define such procedures is to use define with dotted-tail notation. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter’s value will be a list of any remaining arguments. For instance, given the definition

#+begin_src scheme
  (define (f x y . z) <body>)
#+end_src

the procedure f can be called with two or more arguments. If we evaluate

#+begin_src scheme
  (f 1 2 3 4 5 6)
#+end_src

then in the body of f, x will be 1, y will be 2, and z will be the list (3 4 5 6). Given the definition

#+begin_src scheme
  (define (g . w) <body>)
#+end_src

the procedure g can be called with zero or more arguments. If we evaluate

#+begin_src scheme
(g 1 2 3 4 5 6)
#+end_src

then in the body of g, w will be the =list (1 2 3 4 5 6)=.

Use this notation to write a procedure =same-parity= that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,

#+begin_src scheme
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)
(same-parity 2 3 4 5 6 7)
(2 4 6)
#+end_src

#+NAME: same_parity
#+begin_src scheme
  (define (same-parity x . l)
    (define (odd? x) (= (remainder x 2) 1))
    (define (even? x) (= (remainder x 2) 0))
    (define (filter-arity l p)
      (if (null? l)
          #nil
          (let ((tail (filter-arity (cdr l) p))
                (head (car l)))
            (if (p head) (cons head tail) tail))))
    (cons x (filter-arity l (if (odd? x) odd? even?))))
#+end_src

#+begin_src scheme :results replace
<<same_parity>>
(list (same-parity 1 2 3 4 5 6 7)
      (same-parity 2 3 4 5 6 7))
#+end_src

#+RESULTS:
: ((1 3 5 7) (2 4 6))

*Exercise 2.21*. The procedure square-list takes a list of numbers as argument and returns a list of the squares of those numbers.

#+begin_src scheme
(square-list (list 1 2 3 4))
(1 4 9 16)
#+end_src

Here are two different definitions of square-list. Complete both of them by filling in the missing expressions:

#+begin_src scheme
  (define (square-list items)
    (if (null? items)
        nil
        (cons <??> <??>)))
  (define (square-list items)
    (map <??> <??>))
#+end_src

#+begin_src scheme
  (define (square-list items)
    (if (null? items)
        nil
        (cons (square (car items)) (square-list (cdr items)))))
  (define (square-list items)
    (map square items))
#+end_src

*Exercise 2.22*. Louis Reasoner tries to rewrite the first square-list procedure of exercise 2.21 so that it evolves an iterative process:

#+begin_src scheme
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons (square (car things))
                      answer))))
    (iter items nil))
#+end_src

Unfortunately, defining square-list this way produces the answer list in the reverse order of the one desired. Why?

Because it squares in order of the list, but adds the next result to the front.

#+begin_src scheme
(a b c d ...)
(cons (square a) #nil) => (a^2)
(cons (square b) (a^2)) => (b^2 a^2)
...
#+end_src

Louis then tries to fix his bug by interchanging the arguments to cons:

#+begin_src scheme
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons answer
                      (square (car things))))))
    (iter items nil))
#+end_src

This doesn't work either. Explain.

=answer= will be a list, so =cons= ing a list to a list will produce a nested list.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::100][Exercise 2.23]]*. The procedure for-each is similar to map. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, for-each just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all -- for-each is used with procedures that perform an action, such as printing. For example,

#+begin_src scheme
(for-each (lambda (x) (newline) (display x))
(list 57 321 88))
57
321
88
#+end_src

The value returned by the call to for-each (not illustrated above) can be something arbitrary, such as true. Give an implementation of for-each.

#+begin_src scheme
  (define (my-for-each f l) (map f l) #t)
#+end_src
**** 2.2.2 Hierarchical Structures
[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::100][We can treat sequences as *trees*]] if we say that each element that is itself a sequence is a subtree, and others are just leafs.

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::102][Exercise 2.24]]*. Suppose we evaluate the expression (list 1 (list 2 (list 3 4))). Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in figure 2.6).

=(1 (2 (3 4)))=

The box-and-pointer diagram ("X" means nil).

#+begin_src dot :file boxpointer.png :cmdline -Kdot -Tpng :results replace
digraph G {
    // nodesep=.05;
    rankdir=LR;
    node [shape=record,width=1,height=.1];
    // node [shape=record];
    // edge[headclip=false, tailclip=false];
    edge[headclip=true, tailclip=false];

    node1 [label = "{<h> | <t>}"];
    node2 [label = "{<h> | <t> X }"];
    node3 [label = "{<h> | <t> }"];
    node4 [label = "{<h> | <t> X }"];
    node5 [label = "{<h> | <t> }"];
    node6 [label = "{<h> | <t> X }"];

    node [width = 0.5];
    node1a [label = "{ <n> 1}"];
    node3a [label = "{ <n> 2}"];
    node5a [label = "{ <n> 3}"];
    node6a [label = "{ <n> 4}"];

    { rank = same; node1; node1a; }

    { rank = same; node2; node3; node3a; }

    { rank = same; node4; node5; node5a; }

    { rank = same; node6; node6a; }

    node1:h -> node1a:n;
    node1:t -> node2:h;
    node2:h -> node3:h;
    node3:h -> node3a:n;
    node3:t -> node4:h;
    node4:h -> node5:h;
    node5:h -> node5a:n;
    node5:t -> node6:h;
    node6:h -> node6a:n;
}
#+end_src

#+RESULTS:
[[file:pics/boxpointer.png]]

The tree interpretation.

\[
\begin{forest} for tree={align=center}
[(1 (2 (3 4)))
 [1]
 [(2 (3 4))
  [2]
  [(3 4)
   [3]
   [4]]]]
\end{forest}
\]

*Exercise 2.25*. Give combinations of cars and cdrs that will pick 7 from each of the following lists:

#+begin_src scheme
  (1 3 (5 7) 9)
  ((7))
  (1 (2 (3 (4 (5 (6 7))))))
#+end_src

#+begin_src scheme :results output replace
  (define (confirm-ops l x)
    (display l)
    (display " => ")
    (display x)
    (newline))

  (let ((a (list 1 3 (list 5 7) 9))
        (b (list (list 7)))
        (c (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))
    (confirm-ops a (car (cdr (car (cdr (cdr a))))))
    (confirm-ops b (car (car b)))
    (confirm-ops c (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr c))))))))))))))
#+end_src

#+RESULTS:
: "(1 3 (5 7) 9) => 7\n((7)) => 7\n(1 (2 (3 (4 (5 (6 7)))))) => 7\n"

*Exercise 2.26*. Suppose we define x and y to be two lists:

#+NAME: lists
#+begin_src scheme
(define x (list 1 2 3))
(define y (list 4 5 6))
#+end_src

What result is printed by the interpreter in response to evaluating each of the following expressions:

#+NAME: cat_exprs
#+begin_src scheme
(append x y)
(cons x y)
(list x y)
#+end_src

My guess:

#+begin_src scheme
  (1 2 3 4 5 6)
  (1 2 3 (4 5 6)) ; X => ((1 2 3) 4 5 6)
  ((1 2 3) (4 5 6))
#+end_src

Exercise 2.27. Modify your reverse procedure of exercise 2.18 to produce a deep-reverse procedure that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well. For example,
#+begin_src scheme
  (define x (list (list 1 2) (list 3 4)))
  x
  ((1 2) (3 4))
  (reverse x)
  ((3 4) (1 2))
  (deep-reverse x)
  ((4 3) (2 1))
#+end_src

#+NAME: deep_reverse
#+begin_src scheme
  (define (deep-reverse-i l)
    (define (iter li r)
      (if (null? li)
          r
          (iter (cdr li) (cons (deep-reverse-i (car li)) r))))
    (if (not (pair? l))
        l
        (iter l #nil)))
#+end_src

*Exercise 2.28*. Write a procedure fringe that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,

#+begin_src scheme
(define x (list (list 1 2) (list 3 4)))
(fringe x)
(1 2 3 4)
(fringe (list x x))
(1 2 3 4 1 2 3 4)
#+end_src

#+NAME: fringe
#+begin_src scheme
  (define (fringe l)
    (define (iter li r)
      (cond ((null? li) r)
            ((not (pair? li)) (cons li r))
            (else (iter (car li) (iter (cdr li) r)))))
    (iter l #nil))
#+end_src

#+begin_src scheme :results replace
  <<fringe>>
  (define x (list (list 1 2) (list 3 4)))
  (fringe (list x x))
#+end_src

#+RESULTS:
: (1 2 3 4 1 2 3 4)

Exercise 2.29. A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using =list=):

#+NAME: make_mobile
#+begin_src scheme
  (define (make-mobile left right)
    (list left right))
#+end_src

A branch is constructed from a length (which must be a number) together with a structure, which may be either a number (representing a simple weight) or another mobile:

#+NAME: make_branch
#+begin_src scheme
  (define (make-branch length structure)
    (list length structure))
#+end_src

a. Write the corresponding selectors =left-branch= and =right-branch=, which return the branches of a mobile, and =branch-length= and =branch-structure=, which return the components of a branch.

#+NAME: br_selectors
#+begin_src scheme
  (define (left-branch m) (car m))
  (define (right-branch m) (car (cdr m)))
  (define (branch-length b) (car b))
  (define (branch-structure b) (car (cdr b)))
#+end_src

b. Using your selectors, define a procedure =total-weight= that returns the total weight of a mobile.

#+NAME: total_weight
#+begin_src scheme
  <<make_mobile>>
  <<make_branch>>
  <<br_selectors>>
  (define (is-wt? s) (not (pair? s)))

  (define (branch-weight b)
    (let ((w (branch-structure b)))
      (if (is-wt? w)
          w
          (total-weight w))))

  (define (total-weight m)
    (+ (branch-weight (left-branch m))
       (branch-weight (right-branch m))))
#+end_src

#+NAME: test_mobile
#+begin_src scheme
  (define test-mobile
    (make-mobile
   (make-branch 3 (make-mobile
                   (make-branch 3 2)
                   (make-branch 4 5)))
   (make-branch 8 3)))

  (total-weight test-mobile)
#+end_src

#+begin_src scheme :results replace
  <<total_weight>>
  <<test_mobile>>
#+end_src

#+RESULTS:
: 10

c. A mobile is said to be balanced if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.

#+NAME: balanced
#+begin_src scheme
  <<total_weight>>
  (define (is-wt? s) (not (pair? s)))

  (define (branch-balanced? b)
    (let ((s (branch-structure b)))
      (if (is-wt? s)
        #t
        (balanced? s))))

  (define (balanced? m)
    (define (torque b) (* (branch-weight b) (branch-length b)))
    (let ((lb (left-branch m))
          (rb (right-branch m)))
      (and (= (torque lb) (torque rb))
         (branch-balanced? lb)
         (branch-balanced? rb))))
#+end_src

#+NAME: balance_test
#+begin_src scheme
  (map balanced?
       (list
        (make-mobile
         (make-branch 2 (make-mobile (make-branch 1 6) (make-branch 3 2)))
         (make-branch 4 4))
        (make-mobile
         (make-branch 2 (make-mobile (make-branch 2 6) (make-branch 3 2)))
         (make-branch 4 4))))
#+end_src

#+begin_src scheme :results replace
  <<balanced>>
  <<balance_test>>
#+end_src

#+RESULTS:
: (#t #f)

d. Suppose we change the representation of mobiles so that the constructors are

#+NAME: new_rep
#+begin_src scheme
  (define (make-mobile left right)
    (cons left right))
  (define (make-branch length structure)
       (cons length structure))
#+end_src

How much do you need to change your programs to convert to the new representation?

Just =right-branch= and =branch-structure= need to change I think:

#+NAME: new_changes
#+begin_src scheme
(define (right-branch b) (cdr b))
(define (branch-structure b) (cdr b))
#+end_src

#+begin_src scheme :results replace
<<balanced>>
<<new_rep>>

<<new_changes>>
<<balance_test>>
#+end_src

#+RESULTS:
: (#t #f)

#+begin_src scheme :results replace
  <<total_weight>>
  <<new_rep>>
  <<new_changes>>
  <<test_mobile>>
#+end_src

#+RESULTS:
: 10

Exercise 2.30. Define a procedure square-tree analogous to the square-list procedure of exercise 2.21. That is, square-list should behave as follows:

#+begin_src scheme
  (square-tree
   (list 1
  (list 2 (list 3 4) 5)
  (list 6 7)))
  (1 (4 (9 16) 25) (36 49))
#+end_src

Define square-tree both directly (i.e., without using any higher-order procedures) and also by using map and recursion.

#+NAME: st_direct
#+begin_src scheme
  (define (square-tree-d l)
    (cond ((null? l) #nil)
          ((not (pair? l)) (* l l))
          (else (cons (square-tree-d (car l)) (square-tree-d (cdr l))))))
#+end_src

#+NAME: test_tree
#+begin_src scheme
  (define test-tree
    (list 1
          (list 2 (list 3 4) 5)
          (list 6 7)))
#+end_src

#+NAME: st_ho
#+begin_src scheme
  (define (square-tree-ho tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (square-tree-ho sub-tree)
               (* sub-tree sub-tree)))
         tree))
#+end_src

#+begin_src scheme :results replace
<<st_direct>>
<<st_ho>>
<<test_tree>>
(list (square-tree-d test-tree) (square-tree-ho test-tree))
#+end_src

#+RESULTS:
: ((1 (4 (9 16) 25) (36 49)) (1 (4 (9 16) 25) (36 49)))

Exercise 2.31. Abstract your answer to exercise 2.30 to produce a procedure tree-map with the property that square-tree could be defined as

#+NAME: st_tmap
#+begin_src scheme
(define (square-tree tree) (tree-map square tree))
#+end_src

#+NAME: tree_map
#+begin_src scheme
  (define (tree-map f tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (tree-map f sub-tree)
               (f sub-tree)))
         tree))
#+end_src

#+begin_src scheme :results replace
<<square>>
<<tree_map>>
<<st_tmap>>
<<test_tree>>
(square-tree test-tree)
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

*Exercise 2.32*. We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is =(1 2 3)=, then the set of all subsets is =(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))=. Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of why it works:

#+NAME: subsets
#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list #nil)
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+end_src

#+begin_src scheme :results replace
<<subsets>>
(subsets (list 1 2 3))
#+end_src

#+RESULTS:
: (#nil (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))

When you add an element to a set, all the new possible subsets are just the previous subsets plus the new element added to each of them. And by definition, the empty set's only subset is itself.
**** 2.2.3 Sequences as Conventional Interfaces
Procedures we've seen are like [[pdfview:/home/jowalski/usbcrypt/sicp.pdf::105][signals]] "flowing through a cascade of stages, each of which implements part of the program plan". If we implement the signals as lists, we can use list operations to implement each stage. For that we can use the existing =map= procedure we've talked about, in addition to =filter=:

#+NAME: filter
#+begin_src scheme
(define (my-filter p l)
  (cond ((null? l) #nil)
        ((p (car l))
         (cons (car l) (filter p (cdr l))))
        (else (filter p (cdr l)))))
#+end_src

#+NAME: my_accumulate
#+begin_src scheme
(define (accumulate op initial l)
  (if (null? l)
      initial
      (op (car l)
          (accumulate op initial (cdr l)))))
#+end_src

And we can define various enumerate procedures that are useful:

#+NAME: enumerate_interval
#+begin_src scheme
(define (enumerate-interval low high)
  (if (> low high)
      #nil
      (cons low (enumerate-interval (+ low 1) high))))
#+end_src

#+NAME: enumerate_tree
#+begin_src scheme
(define (enumerate-tree tree)
  (cond ((null? tree) #nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree))))))
#+end_src

So we can implement, e.g. =sum-odd-squares-tree= or =even-fibs=:

#+begin_src scheme
(define (sum-odd-squares-tree tree)
  (accumulate +
              0
              (map square
                   (filter odd
                           (enumerate-tree tree)))))
#+end_src

#+begin_src scheme
(define (even-fibs n)
  (accumulate cons
              nil
              (filter even?
                      (map fib
                           (enumerate-interval 0 n)))))
#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::109][Exercise 2.33]]*. Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:

#+NAME: accum_basic_ops
#+begin_src scheme
<<my_accumulate>>
  (define (my-map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) #nil sequence))
  (define (my-append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (my-length sequence)
    (accumulate (lambda (x y) (+ y 1)) 0 sequence))
#+end_src

#+begin_src scheme :results replace
<<accum_basic_ops>>
<<square>>
(define test-list (list 1 2 4 5 7 9))
(list
 (my-map square test-list)
 (my-append test-list test-list)
 (my-length test-list))
#+end_src

#+RESULTS:
: ((1 4 16 25 49 81) (1 2 4 5 7 9 1 2 4 5 7 9) 6)

*Exercise 2.34*. Evaluating a polynomial in x at a given value of x can be formulated as an accumulation. We evaluate the polynomial

\[
a_{n}x^{n} + a_{n-1}x^{n-1} + \hdots + a_{1}x + a_{0}
\]

using a well-known algorithm called Horner’s rule, which structures the computation as

\[
(\hdots (a_{n}x + a_{n-1})x + \hdots + a_{1})x + a_{0}
\]

In other words, we start with \(a_{n}\), multiply by \(x\), add \(a_{n-1}\) , multiply by \(x\), and so on, until we reach \(a_{0}\). Fill in the following template to produce a procedure that evaluates a polynomial using Horner’s rule. Assume that the coefficients of the polynomial are arranged in a sequence, from \(a_{0}\) through \(a_{n}\).

#+NAME: horner
#+begin_src scheme
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))
#+end_src

For example, to compute \(1 + 3x + 5x^{3} + x^{5} \) at \(x = 2\) you would evaluate

#+begin_src scheme :results replace
  <<my_accumulate>>
  <<horner>>
  (horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS:
: 79

*Exercise 2.35*. Redefine =count-leaves= from section 2.2.2 as an accumulation:

#+NAME: count_leaves
#+begin_src scheme
  <<my_accumulate>>
  (define (count-leaves t)
    (accumulate + 0
                   (map (lambda (x)
                                (cond ((null? x) 0)
                                      ((not (pair? x)) 1)
                                      (else (count-leaves x)))) t)))
#+end_src

#+begin_src scheme
<<count_leaves>>
(count-leaves (list (list 1 2) (list 3 (list 4 5)) 6))
#+end_src

*Exercise 2.36*. The procedure =accumulate-n= is similar to accumulate except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if s is a sequence containing four sequences, =((1 2 3) (4 5 6) (7 8 9) (10 11 12))=, then the value of =(accumulate-n + 0 s)= should be the sequence =(22 26 30)=. Fill in the
missing expressions in the following definition of =accumulate-n=:

#+NAME: accumulate_n
#+begin_src scheme
  <<my_accumulate>>
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        #nil
        (cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+end_src

#+begin_src scheme :results replace
  <<accumulate_n>>
  (accumulate-n + 0 (list (list 1 2 3) (list 4 5 6)
                          (list 7 8 9) (list 10 11 12)))
#+end_src

#+RESULTS:
: (22 26 30)

*Exercise 2.37*. Suppose we represent vectors \(v = (v_{i})\) as sequences of numbers, and matrices \(m = (m_{ij})\) as sequences of vectors (the rows of the matrix). For example, the matrix

\[
\begin{bmatrix}
    1 & 2 & 3 & 4 \\
    4 & 5 & 6 & 6 \\
    6 & 7 & 8 & 9
  \end{bmatrix}
\]

is represented as the sequence =((1 2 3 4) (4 5 6 6) (6 7 8 9))=. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:

=(dot-product v w)= returns the sum \(\sum_{i}v_{i}w_{i} \):
=(matrix-*-vector m v)= returns the vector \(t\), where \(t_{i}=\sum_{i}m_{ij}v_{j}\)
=(matrix-*-matrix m n)= returns the matrix \(p\), where \(p_{ij=\sum_{k}m_{ij}n_{kj}}\)
=(transpose m)= returns the matrix \(n\), where \(n_{ij}=m_{ji}\)

We can define the dot product as:

#+NAME: dot_product
#+begin_src scheme
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))
#+end_src

Fill in the missing expressions in the following procedures for computing the other matrix operations. (The procedure =accumulate-n= is defined in exercise 2.36.)

#+begin_src scheme
  <<accumulate_n>>
  <<dot_product>>
  (define (matrix-*-vector m v)
    (map (lambda (m-row) (dot-product v m-row)) m))

  (define (transpose mat)
    (accumulate-n cons #nil mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (m-row) (matrix-*-vector cols m-row)) m)))
#+end_src

*Exercise 2.38*. The =accumulate= procedure is also known as =fold-right=, because it combines the first element of the sequence with the result of combining all the elements to the right.  There is also a =fold-left=, which is similar to =fold-right=, except that it combines elements working in the opposite direction:

#+NAME: fold_left
#+begin_src scheme
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))
#+end_src

What are the values of

#+begin_src scheme
  (fold-right / 1 (list 1 2 3))
  (fold-left / 1 (list 1 2 3))
  (fold-right list nil (list 1 2 3))
  (fold-left list nil (list 1 2 3))
#+end_src

1 / (2 / (1 / 3)) = 1 / 6
(((1 / 1) / 2) / 3) = 1 / 6
(list 1 (list 2 (list 3 #nil))) = (1 (2 (3 #nil)))
(list (list (list #nil 1) 2) 3) = (((#nil 1) 2) 3)

Give a property that =op= should satisfy to guarantee that =fold-right= and
=fold-left= will produce the same values for any sequence.

*Exercise 2.39:* Complete the following definitions of =reverse= (Exercise 2-18) in terms of =fold-right= and =fold-left= from Exercise 2-38

#+begin_src scheme
  <<fold_left>>
  <<my_accumulate>>
  (define fold-right accumulate)

  (define (reverse-fr sequence)
    (fold-right (lambda (x y) (append y (list x))) #nil sequence))

  (define (reverse-fl sequence)
    (fold-left (lambda (x y) (cons y x)) #nil sequence))

#+end_src

A common use of ~accumulate~ / ~fold-right~ is with append, which is called ~[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::112][flatmap]]~.

#+NAME: flatmap
#+begin_src scheme
  <<my_accumulate>>
  (define (flatmap proc sequence)
    (accumulate append #nil (map proc sequence)))
#+end_src


It can be useful to create *permutations* (different orderings) of a set \(S\). The algorithm is: for each item \(x \in S\), generate a sequence of permutations of \(S - x\), and append x to the front.

#+NAME: remove
#+begin_src scheme
(define (remove x l)
   (filter (lambda (y) (not (= x y))) l))
#+end_src

#+NAME: permutations
#+begin_src scheme
  <<remove>>
  (define (permutations s)
    (if (null? s)
        (list #nil)
        (flatmap (lambda (x)
                   (map (lambda (p) (cons x p))
                        (permutations (remove x s))))
                 s)))
#+end_src

#+begin_src scheme

#+end_src

*[[pdfview:/home/jowalski/usbcrypt/sicp.pdf::113][Exercise 2.40]]*. Define a procedure =unique-pairs= that, given an integer \(n\), generates the sequence of pairs \((i,j)\) with \(1 \leq j \leq i \leq n\). Use =unique-pairs= to simplify the definition of =prime-sum-pairs= given above.

#+NAME: unique_pairs
#+begin_src scheme
<<enumerate_interval>>
<<flatmap>>
(define (unique-pairs n)
  (flatmap (lambda (x)
              (map (lambda (y) (list y x))
                   (enumerate-interval 1 (- x 1))))
           (enumerate-interval 1 n)))
#+end_src

#+NAME: prime_sum_pairs
#+begin_src scheme
  <<unique_pairs>>
  <<prime>>
  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

  (define (prime-sum-pairs n)
    (map make-pair-sum (filter prime-sum? (unique-pairs n))))
#+end_src

#+begin_src scheme :results replace
<<prime_sum_pairs>>
(prime-sum-pairs 10)
#+end_src

#+RESULTS:
: ((1 2 3) (2 3 5) (1 4 5) (3 4 7) (2 5 7) (1 6 7) (5 6 11) (4 7 11) (6 7 13) (3 8 11) (5 8 13) (2 9 11) (4 9 13) (8 9 17) (1 10 11) (3 10 13) (7 10 17) (9 10 19))

*Exercise 2.41:* Write a procedure to find all ordered triples of distinct positive integers \(i\), \(j\), and \(k\) less than or equal to a given integer \(n\) that sum to a given integer \(s\).

#+NAME: unique_triples
#+begin_src scheme
<<unique_pairs>>
  (define (sum l) (accumulate + 0 l))

  (define (unique-triples-sum n s)
    (flatmap (lambda (x)
               (filter (lambda (l) (= s (sum l)))
                       (map (lambda (y) (cons y x))
                            (enumerate-interval 1 (- (car x) 1)))))
             (unique-pairs (- n 1))))
#+end_src

#+begin_src scheme :results replace
<<unique_triples>>
(unique-triples-sum 10 12)
#+end_src

#+RESULTS:
: ((3 4 5) (2 4 6) (1 5 6) (2 3 7) (1 4 7) (1 3 8) (1 2 9))

*Exercise 2.42:* The "eight-queens puzzle" asks how to place eight queens on a chessboard so that no queen is in check from any other (i.e., no two queens are in the same row, column, or diagonal). One possible solution is shown in *Note Figure 2-8::.  One way to solve the puzzle is to work across the board, placing a queen in each column.  Once we have placed k - 1 queens, we must place the kth queen in a position where it does not check any of the queens already on the board.  We can formulate this approach recursively: Assume that we have already generated the sequence of all possible ways to place k - 1 queens in the first k - 1 columns of the board.  For each of these ways, generate an extended set of positions by placing a queen in each row of the kth column.  Now filter these, keeping only the positions for which the queen in the kth column is safe with respect to the other queens.  This produces the sequence of all ways to place k queens in the first k columns.  By continuing this process, we will produce not only one solution, but all solutions to the puzzle.

We implement this solution as a procedure ~queens~, which returns a sequence of all solutions to the problem of placing n queens on an n*n chessboard.  ~queens~ has an internal procedure ~queen-cols~ that returns the sequence of all ways to place queens in the first k columns of the board.

#+NAME: queens_alg
#+begin_src scheme
  <<flatmap>>
  <<enumerate_interval>>
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions) (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))
#+end_src

In this procedure ~rest-of-queens~ is a way to place \(k - 1\) queens in the first \(k - 1\) columns, and ~new-row~ is a proposed row in which to place the queen for the kth column.  Complete the program by implementing the representation for sets of board positions, including the procedure ~adjoin-position~, which adjoins a new row-column position to a set of positions, and ~empty-board~, which represents an empty set of positions.  You must also write the procedure ~safe?~, which determines for a set of positions, whether the queen in the kth column is safe with respect to the others.  (Note that we need only check whether the new queen is safe--the other queens are already guaranteed safe with respect to each other.)

#+NAME: queens
#+begin_src scheme
  <<queens_alg>>

  ;; note: in all cases we assume column k is one greater than the
  ;; current size of the board
  (define (adjoin-position new-row k rest-of-queens)
    (cons new-row rest-of-queens))

  (define empty-board (list))

  ;; are there not any other queens on the board on the line running in the
  ;; direction specified by ~dir-fun~ it could be an up-diagonal, horizontal, or
  ;; down-diagonal
  (define (not-on-line? dir-fun k board)
        (if (null? board)
            #t
            (and (not (= (dir-fun k) (car board)))
                 (not-on-line? dir-fun (dir-fun k) (cdr board)))))

  (define (inc x) (+ x 1))                ; up diagonal
  (define (dec x) (- x 1))                ; horizontal
  (define (same x) x)                     ; down diagonal

  (define (safe? col positions)
    (let ((qpos (car positions))
          (rest (cdr positions)))
      ;; is a queen on either of these three lines?
      (and (not-on-line? inc qpos rest) ; up diagonal
           (not-on-line? same qpos rest)      ; horizontal
           (not-on-line? dec qpos rest)
           )))
#+end_src

#+begin_src scheme :results replace
<<queens>>
(queens 5)
#+end_src

#+RESULTS:
: ((4 2 5 3 1) (3 5 2 4 1) (5 3 1 4 2) (4 1 3 5 2) (5 2 4 1 3) (1 4 2 5 3) (2 5 3 1 4) (1 3 5 2 4) (3 1 4 2 5) (2 4 1 3 5))

*Exercise 2.43*. Louis Reasoner is having a terrible time doing Exercise 2.42.  His ~queens~ procedure seems to work, but it runs extremely slowly.  (Louis never does manage to wait long enough for it to solve even the 6*6 case.)  When Louis asks Eva Lu Ator for help, she points out that he has interchanged the order of the nested mappings in the ~flatmap~, writing it as

#+begin_src scheme
  (flatmap
   (lambda (new-row)
     (map (lambda (rest-of-queens)
            (adjoin-position new-row k rest-of-queens))
          (queen-cols (- k 1))))
   (enumerate-interval 1 board-size))
#+end_src

Explain why this interchange makes the program run slowly. Estimate how long will take Louis's program to solve the eight-queens puzzle, assuming that the program in *Note Exercise 2-42 solves the puzzle in time T.

Instead of adding a new column to the set of existing solutions for the (k - 1) problem and placing a queen in that column at each position and checking if it is safe,

he is taking specific row in a new column, finding all existing solutions for (k - 1) and applying them to it, then taking the next row, and yet again finding all existing solutions for (k -1), until all rows in the new column are checked. This is obviously quite redundant, there are (k - 1) repeated checks for each column.

Therefore I'd guess it would take \(T * (k - 1)^{(n - 1)}\) time, or roughly \(T * k^{n}\).
**** 2.2.4 Example: A Picture Language
We create a picture language with procedures that builds images that are shifted and scaled, to illustrate the power of data abstraction and closure. The language is closed under its means of combination.
***** The picture language
Some basic operations are ~beside~ (takes two painters and produces a new, compound painter that draws the first painter's image in the left half of the frame and the second painter's image in the right half of the frame), ~below~ (takes two painters and produces a compound painter that draws the first painter's image below the second painter's image), ~flip-vert~ (takes a painter and produces a painter that draws its image upside-down) and ~flip-horiz~ (produces a painter that draws the original painter left-to-right reversed).

From these we can define these:

#+NAME: painter_start
#+begin_src scheme
  (define (flipped-pairs painter)
    (let ((painter2 (beside painter (flip-vert painter))))
      (below painter2 painter2)))

  (define (right-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (right-split painter (- n 1))))
          (beside painter (below smaller smaller)))))


  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((top-left (beside up up))
                (bottom-right (below right right))
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

  (define (square-limit painter n)
    (let ((quarter (corner-split painter n)))
      (let ((half (beside (flip-horiz quarter) quarter)))
        (below (flip-vert half) half))))
#+end_src

*Exercise 2.44*. Define the procedure ~up-split~ used by ~corner-split~.  It is similar to ~right-split~, except that it switches the roles of ~below~ and ~beside~.

#+NAME: up_split
#+begin_src scheme
  (define (up-split painter n)
    (if (<= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))
#+end_src
***** Higher-order operations
We can abstract patterns of combining painters by combining painter operations, using them as arguments.

#+begin_src scheme
  (define (square-of-four tl tr bl br)
    (lambda (painter)
      (let ((top (beside (tl painter) (tr painter)))
            (bottom (beside (bl painter) (br painter))))
        (below bottom top))))
#+end_src

Then you can define some of the previous operations as:

#+begin_src scheme
  (define (flipped-pairs painter)
    (let ((combine4 (square-of-four identity flip-vert
                                    identity flip-vert)))
      (combine4 painter)))

  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-horiz identity
                                    rotate180 flip-vert)))
      (combine4 (corner-split painter n))))
#+end_src

*Exercise 2.45*. ~Right-split~ and ~up-split~ can be expressed as instances of a general splitting operation.  Define a procedure ~split~ with the property that evaluating

#+begin_src scheme
  (define right-split (split beside below))
  (define up-split (split below beside))
#+end_src

produces procedures ~right-split~ and ~up-split~ with the same behaviors as the ones already defined.

#+NAME: split
#+begin_src scheme
  (define (split l1 l2)
    (define (split-fun painter n)
      (if (= n 0)
          painter
          (let ((smaller (split-fun painter (- n 1))))
            (l1 painter (l2 smaller smaller)))))
    split-fun)
#+end_src
***** Frames
A *frame* can be described by three vectors--an origin and two edge vectors. The constructor ~make-frame~ takes three vectors and produces a frame.

We can create a coordinate map for a frame, that returns a procedure that takes a coordinate in the unit square and maps it to a position on the frame.

#+NAME: frame_coord_map
#+begin_src scheme
  <<frame>>
  (define (frame-coord-map frame)
    (lambda (v)
      (add-vect
       (origin-frame frame)
       (add-vect (scale-vect (xcor-vect v)
                             (edge1-frame frame))
                 (scale-vect (ycor-vect v)
                             (edge2-frame frame))))))
#+end_src

*Exercise 2.46:* A two-dimensional vector v running from the origin to a point can be represented as a pair consisting of an x-coordinate and a y-coordinate.  Implement a data abstraction for vectors by giving a constructor ~make-vect~ and corresponding selectors ~xcor-vect~ and ~ycor-vect~.  In terms of your selectors and constructor, implement procedures ~add-vect~, ~sub-vect~, and ~scale-vect~ that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar:

\[
\begin{align}
(x_1, y_1) + (x_2, y_2) &= (x_1 + x_2, y_1 + y_2) \\
(x_1, y_1) - (x_2, y_2) &= (x_1 - x_2, y_1 - y_2) \\
s \cdot (x, y) &= (sx, sy)
\end{align}
\]

#+NAME: vect
#+begin_src scheme
  (define (make-vect x y) (cons x y))
  (define (xcor-vect v) (car v))
  (define (ycor-vect v) (cdr v))

  (define (add-vect a b)
    (make-vect (+ (xcor-vect a) (xcor-vect b))
               (+ (ycor-vect a) (ycor-vect b))))

  (define (sub-vect a b)
    (add-vect a (make-vect (- (xcor-vect b)) (- (ycor-vect b)))))

  (define (scale-vect s v)
    (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+end_src

*Exercise 2.47*. Here are two possible constructors for frames:

#+begin_src scheme
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))
#+end_src

For each constructor supply the appropriate selectors to produce an implementation for frames.

#+begin_src scheme
  (define (origin-frame f)
    (car f))

  (define (edge1-frame f)
    (cadr f))

  (define (edge2-frame1 f)
    (caddr f))

  (define (edge2-frame2 f)
    (cddr f))
#+end_src
***** Painters
A painter is a procedure that, given a frame, draws an image shifted and scaled to fit the frame. The details of primitive painters depend on particulars of the graphics system and the type of image.

For instance, if we have a primitive ~draw-line~ that draws a line on the screen, we can create a painter for line drawings, defined by lists of line segments, given as pairs of coordinates.

#+NAME: segments_painter
#+begin_src scheme
  <<sdl_setup>>
  <<segment>>
  <<vect>>
  <<frame_coord_map>>
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
         (draw-line
          ((frame-coord-map frame) (start-segment segment))
          ((frame-coord-map frame) (end-segment segment))))
       segment-list)))
#+end_src

*Exercise 2.48:* A directed line segment in the plane can be represented as a pair of vectors--the vector running from the origin to the start-point of the segment, and the vector running from the origin to the end-point of the segment.  Use your vector representation from Exercise 2-46 to define a representation for segments with a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~.

#+NAME: segment
#+begin_src scheme
  (define (make-segment start-vect end-vect)
    (list start-vect end-vect))

  (define (start-segment s) (car s))
  (define (end-segment s) (cadr s))
#+end_src

*Exercise 2.49*. Use ~segments->painter~ to define the following primitive painters:

   a. The painter that draws the outline of the designated frame.

   b. The painter that draws an X by connecting opposite corners of the frame.

   c. The painter that draws a diamond shape by connecting the midpoints of the sides of the frame.

   d. The ~wave~ painter.

   #+NAME: painters
   #+begin_src scheme
     <<segments_painter>>
     (define (four-points-painter f x1f x2f x3f x4f)
       (let ((x1 (x1f f))
             (x2 (x2f f))
             (x3 (x3f f))
             (x4 (x4f f)))
         (segments->painter
          (list (make-segment x1 x2) (make-segment x2 x3)
                (make-segment x3 x4) (make-segment x4 x1)))))

     (define (corner-frame f)
       (add-vect (edge1-frame f) (edge2-frame f)))

     (define (outline f)
       ((four-points-painter f origin-frame edge1-frame
                             corner-frame edge2-frame) f))

     (define (x-painter f)
       ((segments->painter
         (list (make-segment (origin-frame f) (corner-frame f))
               (make-segment (edge1-frame f) (edge2-frame f)))) f))

     (define (midpoint a b) (scale-vect 0.5 (add-vect a b)))

     (define (diamond-painter f)
       (define (midpointf f1 f2)
         (lambda (vect) (midpoint (f1 f) (f2 f))))
       ((four-points-painter f (midpointf origin-frame edge1-frame)
                             (midpointf edge1-frame corner-frame)
                             (midpointf corner-frame edge2-frame)
                             (midpointf edge2-frame origin-frame)) f))

     (define (seglist l)
       (make-segment (make-vect (car l) (cadr l))
                     (make-vect (caddr l) (cadddr l))))

     ;; a list of vectors, turned into a list of segments
     (define (segpath l)
       (if (or (null? l) (null? (cdr l)))
           #nil
           (append (list (make-segment (car l) (cadr l))) (segpath (cdr l)))))

     (define mv make-vect)
     (define wave-segments
       (let ((tleft (segpath
                     (list (mv 0 0.8) (mv 0.2 0.55) (mv 0.3 0.6)
                           (mv 0.4 0.6) (mv 0.35 0.8) (mv 0.4 1))))
             (tright (segpath
                      (list (mv 0.6 1) (mv 0.65 0.8) (mv 0.6 0.6)
                            (mv 0.75 0.6) (mv 1 0.3))))
             (bright (segpath
                      (list (mv 1 0.15) (mv 0.6 0.45) (mv 0.7 0))))
             (bottom (segpath
                      (list (mv 0.6 0) (mv 0.5 0.3) (mv 0.4 0))))
             (bleft (segpath
                     (list (mv 0.3 0) (mv 0.35 0.5) (mv 0.3 0.55)
                           (mv 0.2 0.35) (mv 0 0.6)))))
         (append tleft tright bright bottom bleft)))

     (define wave (segments->painter wave-segments))
   #+end_src

   #+NAME: frame
   #+begin_src scheme
     (define (make-frame origin edge1 edge2)
       (list origin edge1 edge2))
     (define (origin-frame f)
       (car f))

     (define (edge1-frame f)
       (cadr f))

     (define (edge2-frame f)
       (caddr f))
    #+end_src

   #+begin_src scheme
     <<painters>>
     (define screenf (make-frame (mv 0 0) (mv 1 0) (mv 0 1)))
     (wave screenf)
     (clear-screen)
     (outline screenf)
     (clear-screen)
     (x-painter screenf)
     (clear-screen)
     (diamond-painter screenf)
   #+end_src


   The setup for graphics on my system, requires sdl libraryfor scheme and system installed.

   #+NAME: sdl_setup
   #+begin_src scheme
     (define (init-gfx)
       (use-modules ((sdl sdl) #:prefix SDL:)
                    ((sdl gfx) #:prefix GFX:))
       (SDL:init 'video)

       (let* ((DEPTH 32)
              (width 640)
              (height 640)
              (SCREEN (begin (SDL:set-video-mode width height DEPTH)
                             (SDL:get-video-surface)))
              (cscreen (lambda () (SDL:fill-rect SCREEN #f #xffffff)
                               (SDL:flip)))
              (random-rgb (lambda () (random #x1000000)))
              (color (random-rgb))
              (rnd (lambda (x) (inexact->exact (round x))))
              (nrmx (lambda (x) (rnd (* x width))))
              (nrmy (lambda (y) (rnd (- height (* y height)))))
              (barest-hint (logior #x08 (logand color (lognot #xff)))))
         (cscreen)
         (list (lambda (p1 p2)
                 ;; lambda (x1 y1 x2 y2)
                 (GFX:draw-thick-line SCREEN (nrmx (xcor-vect p1)) (nrmy (ycor-vect p1))
                                      (nrmx (xcor-vect p2)) (nrmy (ycor-vect p2)) 3 color)
                 ;; (GFX:draw-line SCREEN x1 y1 x2 y2 color)
                 (SDL:flip))
               cscreen
               SCREEN
               (lambda (filename)
                 (SDL:save-bmp SCREEN filename)
                 (quit-gfx))))
       )

     (define gfx-state (init-gfx))

     ;; takes arguments on the normalized (x, y) scale (origin = (0,0), top right
     ;; corner = (1,1))
     (define draw-line (car gfx-state))
     (define clear-screen (cadr gfx-state))
     ;; (define SCREEN (caddr gfx-state))
     (define save-screen (cadddr gfx-state))
     (define (quit-gfx) (SDL:quit))
   #+end_src
***** Transforming and combining painters

We can define operations on procedures, such as ~flip-vert~ or ~beside~ based on a procedure ~transform_painter~, that a painter and coordinates of a new frame to project onto.

#+NAME: transform_painter
#+begin_src scheme
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
        (let ((new-origin (m origin)))
          (painter
           (make-frame new-origin
                       (sub-vect (m corner1) new-origin)
                       (sub-vect (m corner2) new-origin)))))))
#+end_src

#+NAME: transforms
#+begin_src scheme
  (define (flip-vert painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)   ; new `origin'
                       (make-vect 1.0 1.0)   ; new end of `edge1'
                       (make-vect 0.0 0.0))) ; new end of `edge2'

  (define (shrink-to-upper-right painter)
    (transform-painter painter
                       (make-vect 0.5 0.5)
                       (make-vect 1.0 0.5)
                       (make-vect 0.5 1.0)))

  (define (rotate90 painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  (define (squash-inwards painter)
    (transform-painter painter
                       (make-vect 0.0 0.0)
                       (make-vect 0.65 0.35)
                       (make-vect 0.35 0.65)))
#+end_src

We could also define compound painters that transform multiple painters, for example ~beside~:

#+NAME: beside
#+begin_src scheme
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                split-point
                                (make-vect 0.0 1.0)))
            (paint-right
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.0)
                                (make-vect 0.5 1.0))))
        (lambda (frame)
          (paint-left frame)
          (paint-right frame)))))
#+end_src

*Exercise 2.50:* Define the transformation `flip-horiz', which flips painters horizontally, and transformations that rotate painters counterclockwise by 180 degrees and 270 degrees.

#+NAME: transforms_2
#+begin_src scheme
  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.1 1.1)))

  (define (rotate180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  (define (rotate270 painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))
#+end_src

#+begin_src scheme
     <<painters>>
     <<transform_painter>>
     <<transforms_2>>
     (define screenf (make-frame (mv 0 0) (mv 1 0) (mv 0 1)))
     ((flip-horiz wave) screenf)
     (clear-screen)
     ((rotate180 wave) screenf)
     (clear-screen)
     ((rotate270 wave) screenf)
#+end_src

*Exercise 2.51*. Define the ~below~ operation for painters. ~below~ takes two painters as arguments.  The resulting painter, given a frame, draws with the first painter in the bottom of the frame and with the second painter in the top.  Define ~below~ in two different ways--first by writing a procedure that is analogous to the `beside' procedure given above, and again in terms of `beside' and suitable rotation operations (from Exercise 2-50).

#+NAME: below
#+begin_src scheme
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-bottom
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point))
            (paint-top
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.5)
                                (make-vect 0.0 1.0))))
        (lambda (frame)
          (paint-bottom frame)
          (paint-top frame)))))

  (define (below-r painter1 painter2)
    (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))
#+end_src

#+begin_src scheme
  <<painters>>
  <<transform_painter>>
  <<beside>>
  <<transforms>>
  <<transforms_2>>
  <<below>>
  (define screenf (make-frame (mv 0 0) (mv 1 0) (mv 0 1)))
  ((below wave wave) screenf)
  (clear-screen)
  ((below-r wave wave) screenf)
  (save-screen "pics/2_2_wavebelow.bmp")
#+end_src

[[file:pics/2_2_wavebelow.bmp]]
***** Levels of language for robust design
By using procedural representations for underlying data objects, we can take advantage of the closure property to easily build complex designs. Another idea we've seen is *stratified design*, combining parts at each level that are primitive to that level, so that the language has primitives, means of combination, and means of abstraction appropriate to that level of detail.

Stratified design helps make programs *robust*, likely that small changes in specification will require small changes in the program.

*Exercise 2.52:* Make changes to the square limit of `wave' shown in *Note Figure 2-9:: by working at each of the levels described above.  In particular:

a. Add some segments to the primitive `wave' painter of Exercise 2-49 (to add a smile, for example).

#+NAME: wave_smile
#+begin_src scheme
  (define eyes-and-smile
    (let ((left-eye (segpath (list (mv 0.45 0.85) (mv 0.47 0.85))))
          (right-eye (segpath (list (mv 0.53 0.85) (mv 0.55 0.85))))
          (smile (segpath
                  (list (mv 0.42 0.72) (mv 0.45 0.69)
                        (mv 0.5 0.67) (mv 0.55 0.69) (mv 0.58 0.72)))))
      (append left-eye right-eye smile)))

  (define wave-smile (segments->painter (append wave-segments eyes-and-smile)))
#+end_src

#+begin_src scheme
<<painters>>
  (define screenf (make-frame (mv 0 0) (mv 1 0) (mv 0 1)))
  (wave-smile screenf)
#+end_src

b. Change the pattern constructed by ~corner-split~ (for example, by using only one copy of the ~up-split~ and ~right-split~ images instead of two).

c. Modify the version of `square-limit' that uses `square-of-four' so as to assemble the corners in a different pattern.  (For example, you might make the big Mr. Rogers look outward from each corner of the square.)
*** 2.3 Symbolic Data
**** 2.3.1 Quotation
We can also *quote* data objects in the language, using the single quote symbol ~'~, which is all we need to quote next object. ~eq?~ tests whether two symbols are the same.

We can create an operation that returns the sublist of the list beginning with the first occurrence of the symbol.

#+begin_src scheme
  (define (memq item x)
    (cond ((null? x) false)
          ((eq? item (car x)) x)
          (else (memq item (cdr x)))))
#+end_src

*Exercise 2.53:* What would the interpreter print in response to evaluating each of the following expressions?

#+begin_src scheme
  (list 'a 'b 'c)
  (list (list 'george))
  (cdr '((x1 x2) (y1 y2)))
  (cadr '((x1 x2) (y1 y2)))
  (pair? (car '(a short list)))
  (memq 'red '((red shoes) (blue socks)))
  (memq 'red '(red shoes blue socks))
#+end_src

~(a b c)~
~((george))~
~((y1 y2))~
~(y1 y2)~
~#f~
~#f~
~(red shoes blue socks)~

*Exercise 2.54:* Two lists are said to be ~equal?~ if they contain equal elements arranged in the same order.  For example,

#+begin_src scheme :results replace
  <<equal>>
  (equal? '(this is a list) '(this is a list))
#+end_src

#+RESULTS:
: #t

is true, but

#+begin_src scheme :results replace
  <<equal>>
  (equal? '(this is a list) '(this (is a) list))
#+end_src

#+RESULTS:
: #f

is false.  To be more precise, we can define ~equal?~ recursively in terms of the basic ~eq?~ equality of symbols by saying that \(a\) and \(b\) are ~equal?~ if they are both symbols and the symbols are ~eq?~, or if they are both lists such that ~(car a)~ is ~equal?~ to ~(car b)~ and ~(cdr a)~ is ~equal?~ to ~(cdr b)~.  Using this idea, implement ~equal?~ as a procedure.

#+NAME: equal
#+begin_src scheme
  (define (equal? a b)
    (or (and (null? a) (null? b))
        (and (symbol? a) (symbol? b) (eq? a b))
        (and (pair? a) (pair? b)
             (equal? (car a) (car b))
             (equal? (cdr a) (cdr b)))))
#+end_src

*Exercise 2.55:* Eva Lu Ator types to the interpreter the expression

#+begin_src scheme
  (car ''abracadabra)
#+end_src

To her surprise, the interpreter prints back `quote'.  Explain.

Answer: it looks like ~'~ is just an abbreviation for the function ~quote~, so ~(car (quote (quote abracadabra)))~ is the same as ~(car '(quote abracadabra))~, which should naturally be ~quote~.

Interestingly, but appropriately, ~quote~ prevents any internal values from being evaluated.
**** 2.3.2 Example: Symbolic Differentiation
We develop a symbolic-differentiation program, with expressions represented as symbols, in lisp-style.

Note the basic algorithm for differentiation of constants, sums and products.

#+NAME: deriv_orig
#+begin_src scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          (else
           (error "unknown expression type -- DERIV" exp))))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-sum a1 a2) (list '+ a1 a2))
  (define (make-product m1 m2) (list '* m1 m2))
  (define (sum? x)
    (and (pair? x) (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s) (caddr s))
  (define (product? x)
    (and (pair? x) (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p) (caddr p))
#+end_src

This doesn't reduce answers to their simplest form, however. We can make changes to ~make-sum~ to handle this, by summing terms that are numbers.

#+NAME: make_sum
#+begin_src scheme
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list '+ a1 a2))))
  (define (=number? exp num)
          (and (number? exp) (= exp num)))
#+end_src

And similarly for ~make-product~:

#+NAME: make_product
#+begin_src scheme
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list '* m1 m2))))
#+end_src

*Exercise 2.56:* Show how to extend the basic differentiator to handle more kinds of expressions.  For instance, implement the differentiation rule

\[
\frac{d(u^{n})}{dx} = nu^{n-1}\left(\frac{du}{dx}\right)
\]

by adding a new clause to the ~deriv~ program and defining appropriate procedures ~exponentiation?~, ~base~, ~exponent~, and ~make-exponentiation~.  (You may use the symbol ~**~ to denote exponentiation.)  Build in the rules that anything raised to the power 0 is 1 and anything raised to the power 1 is the thing itself.

#+NAME: deriv_exp
#+begin_src scheme
  <<deriv_orig>>
  <<make_sum>>
  <<make_product>>
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (let ((n (exponent exp)))
            (make-product
             (make-product n
                           (make-exponentiation (base exp) (- n 1)))
                           (deriv (base exp) var))))
          (else
           (error "unknown expression type -- DERIV" exp))))

  (define (exponentiation? x)
    (and (pair? x) (eq? (car x) '**)))
  (define (exponent x) (caddr x))
  (define (make-exponentiation u n)
    (cond ((=number? n 0) 1)
          ((=number? n 1) u)
          (else (list '** u n))))
  (define (base x) (cadr x))
#+end_src

#+begin_src scheme :results replace
<<deriv_exp>>
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: (+ (* x y) (* y (+ x 3)))

#+begin_src scheme :results replace
<<deriv_exp>>
(deriv '(+ (** x 3) (* 5 (** x 2))) 'x)
#+end_src

#+RESULTS:
: (+ (* 3 (** x 2)) (* 5 (* 2 x)))

*Exercise 2.57:* Extend the differentiation program to handle sums and products of arbitrary numbers of (two or more) terms.  Then the last example above could be expressed as

#+begin_src scheme
     (deriv '(* x y (+ x 3)) 'x)
#+end_src

Try to do this by changing only the representation for sums and products, without changing the ~deriv~ procedure at all.  For example, the ~addend~ of a sum would be the first term, and the ~augend~ would be the sum of the rest of the terms.

#+NAME: sum_arb
#+begin_src scheme
  (define (augend s)
    (let ((t3 (cddr s)))
      (if (null? (cdr t3))
        (car t3)
        (append (make-sum (car t3) (cadr t3)) (cddr t3)))))
  (define (multiplicand p)
    (if (null? (cdddr p))
        (caddr p)
        (append (make-product (caddr p) (cadddr p)) (cddddr p))))
#+end_src

#+begin_src scheme :results replace
  <<deriv_exp>>
  <<sum_arb>>
  (deriv '(* x y (+ x 3)) 'x)
#+end_src

#+RESULTS:
: (+ (* x y) (* y (+ x 3)))

*Exercise 2.58:* Suppose we want to modify the differentiation program so that it works with ordinary mathematical notation, in which `+' and `*' are infix rather than prefix operators.  Since the differentiation program is defined in terms of abstract data, we can modify it to work with different representations of expressions solely by changing the predicates, selectors, and constructors that define the representation of the algebraic expressions on which the differentiator is to operate.

a. Show how to do this in order to differentiate algebraic expressions presented in infix form, such as ~(x + (3 * (x + (y + 2))))~.  To simplify the task, assume that ~+~ and ~*~ always take two arguments and that expressions are fully parenthesized.

#+NAME: infix
#+begin_src scheme
  <<deriv_exp>>
  ;; these define infix vs prefix notation
  (define (list-op op t1 t2) (list t1 op t2))
  (define (op? symb)
    (lambda (x) (and (pair? x) (eq? (cadr x) symb))))
  (define (first-term x) (car x))
  ;; (define (second-term x) (caddr x))

  (define addend first-term)
  (define multiplier first-term)
  (define base first-term)

  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list-op '+ a1 a2))))
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list-op '* m1 m2))))
  (define (make-exponentiation u n)
    (cond ((=number? n 0) 1)
          ((=number? n 1) u)
          (else (list-op '** u n))))

  (define sum? (op? '+))
  (define product? (op? '*))
  (define exponentiation? (op? '**))
#+end_src

#+begin_src scheme :results replace
  <<infix>>
  (deriv '(x + (3 * (x + (y + 2)))) 'x)
#+end_src

#+RESULTS:
: 4

#+begin_src scheme :results replace
<<infix>>
  (deriv '((x * y) * (x + 3)) 'x)
#+end_src

#+RESULTS:
: ((x * y) + (y * (x + 3)))

b. The problem becomes substantially harder if we allow standard algebraic notation, such as ~(x + 3 * (x + y + 2))~, which drops unnecessary parentheses and assumes that multiplication is done before addition.  Can you design appropriate predicates, selectors, and constructors for this notation such that our derivative program still works?

#+NAME: infix_noparen
#+begin_src scheme
  <<infix>>
  ;; operator precedence functions
  (define op-order '(+ * **))
  (define (op-value o)
    (define (iter olist n)
      (if (and (pair? olist) (eq? o (car olist)))
          n
          (iter (cdr olist) (+ n 1))))
    (iter op-order 1))
  (define (cmp-op o1 o2)
    (<= (op-value o1) (op-value o2)))

  ;; expression splitting
  (define op-term cadr)
  (define (op-pos x)
    (define (iter x op pos)
      (if (or (null? x) (null? (cdr x)))
          pos
          (let ((cur-op (op-term x)))
            (if (cmp-op op cur-op)
              (iter (cddr x) op pos)
              (iter (cddr x) cur-op (+ pos 2))))))
    (iter x (op-term x) 2))
  (define (parens? exp)
    (and (pair? exp) (null? (cdr exp)) (not (null? (car exp)))))
  (define (no-parens exp)
    (if (not (parens? exp))
        exp
        (no-parens (car exp))))
  (define (split-at-pos x pos)
    (define (iter left right i)
      (if (= i pos)
          (list (car right) (reverse left) (cdr right))
          (iter (cons (car right) left) (cdr right) (+ i 1))))
    (let ((split-w-parens (iter #nil x 1)))
      (list (car split-w-parens)
            (no-parens (cadr split-w-parens))
            (no-parens (caddr split-w-parens)))))

  ;; main function, splits an expression into 3 parts:
  ;; 1 - the operator with highest precedence, 2 - the expression
  ;; to the left of that operator, 3 - the expression to the right
  (define (split-exp x)
    (split-at-pos x (op-pos x)))

  ;; generic operations
  (define (first-term exp)
    (cadr (split-exp exp)))
  (define (operator exp)
    (car (split-exp exp)))
  (define (other-term exp)
    (caddr (split-exp exp)))

  (define (op? symb)
    (lambda (x)
            (and (pair? x) (eq? (operator x) symb))))
  (define sum? (op? '+))
  (define product? (op? '*))
  (define exponentiation? (op? '**))

  (define augend other-term)
  (define multiplicand other-term)
  (define exponent other-term)

  (define addend first-term)
  (define multiplier first-term)
  (define base first-term)
#+end_src

#+begin_src scheme :results replace
<<infix_noparen>>
(deriv '(x + 3 * (x + y + 2)) 'x)
#+end_src

#+RESULTS:
: 4
**** 2.3.3 Example: Representing Sets
To give a precise definition of sets, we can use data abstraction, and specify the operations that are to be used *on sets*. These will be ~union-set~, ~intersection-set~, ~adjoin-set~ and ~element-of-set?~. (Adjoin takes a set and adds an element to it).
***** Sets as unordered lists
One implementation is with unordered lists.

#+begin_src scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  (define (intersection-set s1 s2)
    (define (iter s res)
      (if (null? s)
          res
          (iter (cdr s) (if (element-of-set? (car s) s2)
                            (cons (car s) res)
                            res))))
    (if (null? s2)
        #nil
        (iter s1 #nil)))
#+end_src

Note: it's important to keep in mind the efficiency of ~element-of-set~, since it's called in ~intersection-set~ for each element of its first argument, ~s1~.

*Exercise 2.59*. Implement the ~union-set~ operation for the unordered-list representation of sets.

#+begin_src scheme
  (define (union-set s1 s2)
    (cond ((null? s1) s2)
          ((null? s2) s1)
          (else (union-set (cdr s1) (adjoin-set (car s1) s2)))))
#+end_src

*Exercise 2.60*. We specified that a set would be represented as a list with no duplicates.  Now suppose we allow duplicates.  For instance, the set {1,2,3} could be represented as the list ~(2 3 2 1 3 2 2)~.  Design procedures ~element-of-set?~, ~adjoin-set~, ~union-set~, and ~intersection-set~ that operate on this representation.  How does the efficiency of each compare with the corresponding procedure for the non-duplicate representation?  Are there applications for which you would use this representation in preference to the non-duplicate one?

#+begin_src scheme
  (define (element-of-set? x set)
    (if (null? set)
        #f
        (or (equal? x (car set)) (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (cons x set))

  (define (union-set s1 s2)
    (append s1 s2))

  (define (intersection-set s1 s2)
    (cond ((or (null? s1) (null? s2)) #nil)
          ((element-of-set? (car s1) s2)
           (cons (car s1) (intersection-set (cdr s1) s2)))
          (else (intersection-set (cdr s1) s2))))
#+end_src

The only change to the procedures are with ~adjoin-set~ and ~union-set~, which are in fact now faster, \(\Theta(1)\) and \(\Theta(n)\) in speed. However, the lists representing sets will generally be larger since they contain duplicates, so ~element-of-set?~ will take longer, and thus ~intersection-set~.

This would be advantageous in situations where there are many operations that add to sets, but relatively few where ~element-of-set?~ or ~intersection~ is called, or the speed of those operations are less critical.
***** Sets as ordered lists
Using ordered lists can speed up some procedures.

~element-of-set~ can stop doing comparisons once it's reached elements that are lexicographically greater than the comparator.

#+NAME: element_ord
#+begin_src scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (car set)) #t)
          ((< x (car set)) #f)
          (else (element-of-set? x (cdr set)))))
#+end_src

This saves on average half the time.

#+NAME: intersect_ord
#+begin_src scheme
  (define (intersection-set s1 s2)
    (define (iter s1 s2 res)
      (if (or (null? s1) (null? s2))
          res
          (let ((x1 (car s1))
                (x2 (car s2)))
            (cond ((= x1 x2)
                   (iter (cdr s1) (cdr s2) (cons x1 res)))
                  ((< x1 x2)
                   (iter (cdr s1) s2 res))
                  (else (iter s1 (cdr s2) res))))))
    (reverse (iter s1 s2 '())))
#+end_src

*Exercise 2.61*. Give an implementation of ~adjoin-set~ using the ordered representation.  By analogy with ~element-of-set?~ show how to take advantage of the ordering to produce a procedure that requires on the average about half as many steps as with the unordered representation.

#+NAME: adjoin_ord
#+begin_src scheme
  (define (adjoin-set x set)
    (cond ((null? set) (list x))
          ((= x (car set)) set)
          ((< x (car set)) (cons x set))
          (else (cons (car set) (adjoin-set x (cdr set))))))
#+end_src

#+NAME: make_set
#+begin_src scheme
  (define (make-set l)
    (if (null? l)
        '()
        (adjoin-set (car l) (make-set (cdr l)))))
#+end_src

#+begin_src scheme :results replace
  <<element_ord>>
  <<intersect_ord>>
  <<adjoin_ord>>
  <<make_set>>
  (element-of-set? 3 (intersection-set (make-set '(6 2 3 4 9))
                                       (make-set '(5 1 4 2 3))))
#+end_src

#+RESULTS:
: #t

*Exercise 2.62*. Give a \(\Theta(n)\) implementation of ~union-set~ for sets represented as ordered lists.

#+NAME: union_ord
#+begin_src scheme
  (define (union-set s1 s2)
    (cond ((null? s1) s2)
          ((null? s2) s1)
          ((= (car s1) (car s2))
           (cons (car s1) (union-set (cdr s1) (cdr s2))))
          ((< (car s1) (car s2))
           (cons (car s1) (union-set (cdr s1) s2)))
          (else (cons (car s2) (union-set s1 (cdr s2))))))
#+end_src

#+begin_src scheme :results replace
  <<element_ord>>
  <<intersect_ord>>
  <<adjoin_ord>>
  <<union_ord>>
  <<make_set>>
  (union-set (make-set '(6 2 3 4 9))
             (make-set '(5 1 4 2 3)))
#+end_src

#+RESULTS:
: (1 2 3 4 5 6 9)

***** Sets as binary trees
A better representation of sets uses binary trees, which can improve speed to \(log(n)\).

#+NAME: bin_tree
#+begin_src scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-tree entry left right)
    (list entry left right))
#+end_src

#+NAME: element_bin
#+begin_src scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (entry set)) #t)
          ((< x (entry set))
           (element-of-set? x (left-branch set)))
          ((> x (entry set)) (element-of-set? x (right-branch set)))))
#+end_src

#+NAME: adjoin_bin
#+begin_src scheme
  (define (adjoin-set x set)
    (cond ((null? set) (make-tree x '() '()))
          ((= x (entry set)) set)
          ((< x (entry set))
           (make-tree (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch set)))
          ((> x (entry set))
           (make-tree (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set))))))
#+end_src

Note: the inference that the tree can be searched in \(\log{n}\) steps rests on the assumption that the tree is balanced. If all entries were along one side of the tree, it would obviously require \(\Theta(n)\)
.

One way to deal with this is re-balancing the tree after a certain amount of ~adjoin-set~ operations. Other data structures can ensure \(Theta(\log{n})\).

*Exercise 2.63*. Each of the following two procedures converts a binary tree to a list.

#+NAME: tree_to_list
#+begin_src scheme
  (define (tree->list-1 tree)
    (if (null? tree)
        '()
        (append (tree->list-1 (left-branch tree))
                (cons (entry tree)
                      (tree->list-1 (right-branch tree))))))

  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))
#+end_src

a. Do the two procedures produce the same result for every tree? If not, how do the results differ?  What lists do the two procedures produce for the trees in *Note Figure 2-16?

#+begin_src scheme :results replace
  <<make_set>>
  <<bin_tree>>
  <<tree_to_list>>
  <<adjoin_bin>>
  (define (mktree l) (make-set (reverse l)))
  (let ((tree1 (mktree '(7 3 9 1 5 11)))
        (tree2 (mktree '(3 1 7 5 9 11)))
        (tree3 (mktree '(5 3 1 9 7 11))))
    (list (map tree->list-1 (list tree1 tree2 tree3))
          (map tree->list-2 (list tree1 tree2 tree3))))
#+end_src

#+RESULTS:
: (((1 3 5 7 9 11) (1 3 5 7 9 11) (1 3 5 7 9 11)) ((1 3 5 7 9 11) (1 3 5 7 9 11) (1 3 5 7 9 11)))

Both would seem to produce ~'(1 3 5 7 9 11)~ in all cases.

b. Do the two procedures have the same order of growth in the number of steps required to convert a balanced tree with n elements to a list?  If not, which one grows more slowly?

It looks like for every node in the tree, the first procedure calls both ~append~ and ~cons~ once, since it only doesn't when a tree is null. However, the second procedure calls just ~cons~ once for each node, so it would seem it eliminates \(n\) calls to ~append~.

*Exercise 2.64*. The following procedure ~list->tree~ converts an ordered list to a balanced binary tree.  The helper procedure ~partial-tree~ takes as arguments an integer n and list of at least n elements and constructs a balanced tree containing the first n elements of the list.  The result returned by ~partial-tree~ is a pair (formed with ~cons~) whose ~car~ is the constructed tree and whose ~cdr~ is the list of elements not included in the tree.

#+NAME: list_tree
#+begin_src scheme
  (define (list->tree elements)
    (car (partial-tree elements (length elements))))

  (define (partial-tree elts n)
    (if (= n 0)
        (cons '() elts)
        (let ((left-size (quotient (- n 1) 2)))
          (let ((left-result (partial-tree elts left-size)))
            (let ((left-tree (car left-result))
                  (non-left-elts (cdr left-result))
                  (right-size (- n (+ left-size 1))))
              (let ((this-entry (car non-left-elts))
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                (let ((right-tree (car right-result))
                      (remaining-elts (cdr right-result)))
                  (cons (make-tree this-entry left-tree right-tree)
                        remaining-elts))))))))
#+end_src

a. Write a short paragraph explaining as clearly as you can how ~partial-tree~ works.  Draw the tree produced by ~list->tree~ for the list ~(1 3 5 7 9 11)~.

The procedure takes a list of elements (of some size) and a size n, and first creates a partial tree of size \(\frac{n-1}{2}\) (the lowest integer) for the left side. Whatever elements it doesn't use, it creates a tree from the first element in that list and a partial tree of size \(\frac{n - 1}{2} - 1\) of the rest of those elements. It then returns a list consisting of the resulting tree, and whatever elements weren't used. Since the input list is ordered, the effect is for a list of three elements, you get the first element in the left branch, the second element in the middle, and the third element on the right branch. (The result for lists of size one and two is clear.) For lists of larger size, you can show by induction that you get "balanced" trees of the first ~~ \(\frac{n-1}{2}\) elements on the left side, the middle element at root, and a balanced tree of the rest of elements on the right side.

\[
\begin{forest}
[5
 [3
  [1]]
 [9
  [7]
  [11]]]
\end{forest}
\]

b. What is the order of growth in the number of steps required by ~list->tree~ to convert a list of n elements?

~partial-tree~ calls ~make-tree~ once for each call to ~partial-tree~ where ~n~ is not 0, and it calls partial-tree twice each time ~(quotient (- n 1) 2)~ is not 0, which will happen when it is 1, which happens once for each element in the list, and when it is combining trees of size 1, and their super-trees, which happens \(\frac{n}{2}\) times, so the order of growth should be \(\Theta(n)\).

*Exercise 2.65*. Use the results of Exercise 2-63 and Exercise 2-64 to give \(\Theta(n)\) implementations of ~union-set~ and ~intersection-set~ for sets implemented as (balanced) binary trees.

#+NAME: set_balanced
#+begin_src scheme
  (define (union-set s1 s2)
    (define (union-olists l1 l2)
      (cond ((null? l1) l2)
            ((null? l2) l1)
            ((= (car l1) (car l2))
             (cons (car l1) (union-olists (cdr l1) (cdr l2))))
            ((< (car l1) (car l2))
             (cons (car l1) (union-olists (cdr l1) l2)))
            (else (cons (car l2) (union-olists l1 (cdr l2))))))
    (list->tree (union-olists (tree->list-2 s1)
                              (tree->list-2 s2))))

  (define (intersection-set s1 s2)
    (define (intersection-olists l1 l2)
      (if (or (null? l1) (null? l2))
          '()
          (let ((x1 (car l1))
                (x2 (car l2)))
            (cond ((= x1 x2)
                   (cons x1 (intersection-olists (cdr l1) (cdr l2))))
                  ((< x1 x2)
                   (intersection-olists (cdr l1) l2))
                  ((> x1 x2)
                   (intersection-olists l1 (cdr l2)))))))
    (list->tree (intersection-olists (tree->list-2 s1) (tree->list-2 s2))))
#+end_src

#+begin_src scheme :results replace
  <<bin_tree>>
  <<element_bin>>
  <<adjoin_bin>>
  <<tree_to_list>>
  <<list_tree>>
  <<set_balanced>>
  <<make_set>>

  (let ((s1 (make-set '(3 5 1 8 4 )))
        (s2 (make-set '(6 2 8 3 9))))
    (list (union-set s1 s2) (intersection-set s1 s2)))
#+end_src

#+RESULTS:
: ((4 (2 (1 () ()) (3 () ())) (6 (5 () ()) (8 () (9 () ())))) (3 () (8 () ())))
***** Sets and information retrieval
These techniques used in implementing sets come up again in database retrieval, where efficient methods for accessing records are important.

One such example is using an identifying *key* for retrieving a record, the keys must be unique and so constitute a set. To implement this we need to define a ~lookup~ procedure, similar to ~element-of-set~.

If implementing with an unordered list (not the most efficient), the procedure might be:

#+begin_src scheme
  (define (lookup given-key set-of-records)
    (cond ((null? set-of-records) false)
          ((equal? given-key (key (car set-of-records)))
           (car set-of-records))
          (else (lookup given-key (cdr set-of-records)))))
#+end_src

*Exercise 2.66:* Implement the ~lookup~ procedure for the case where the set of records is structured as a binary tree, ordered by the numerical values of the keys.

#+begin_src scheme
  (define (lookup given-key records)
    (cond ((null? records) #f)
          ((= given-key (key records))
           (record records))
          ((< given-key (key records))
           (lookup given-key (left-branch records)))
          ((> given-key (key records))
           (lookup given-key (right-branch records)))))
#+end_src
**** 2.3.4 Example: Huffman Encoding Trees
